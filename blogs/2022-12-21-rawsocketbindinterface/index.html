<!doctype html><html lang=cn dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>绑定RawSocket与Interface | Play With YYF</title><meta name=keywords content="博客"><meta name=description content="在做以太网的回环测试时，需要实现指定MAC发送RawSocket报文，然后指定MAC接收回环过来的RawSocket报文。这就需要将socket绑定到网络接口（eth0,eth1），rawsocket的绑定方式与其他socket还不一样，研究了一下发现可以通过下面的方式实现。
从特定网络接口接收raw socket报文 如果是 AF_INET sockets 可以用 setsockopt() 来实现:
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); /* SO_BINDTODEVICE Bind this socket to a particular device like &#34;eth0&#34;, as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ."><meta name=author content="Ye Yunfei"><link rel=canonical href=https://yyf.zone/blogs/2022-12-21-rawsocketbindinterface/><link crossorigin=anonymous href=/assets/css/stylesheet.min.1e44d58192cbf6d7a4eb649bc43dbc3d4cc432677e5d8adc69b08c34cbe461ac.css integrity="sha256-HkTVgZLL9tek62SbxD28PUzEMmd+XYrcabCMNMvkYaw=" rel="preload stylesheet" as=style><link rel=icon href=https://yyf.zone/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yyf.zone/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yyf.zone/favicon-32x32.png><link rel=apple-touch-icon href=https://yyf.zone/apple-touch-icon.png><link rel=mask-icon href=https://yyf.zone/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="绑定RawSocket与Interface"><meta property="og:description" content="在做以太网的回环测试时，需要实现指定MAC发送RawSocket报文，然后指定MAC接收回环过来的RawSocket报文。这就需要将socket绑定到网络接口（eth0,eth1），rawsocket的绑定方式与其他socket还不一样，研究了一下发现可以通过下面的方式实现。
从特定网络接口接收raw socket报文 如果是 AF_INET sockets 可以用 setsockopt() 来实现:
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); /* SO_BINDTODEVICE Bind this socket to a particular device like &#34;eth0&#34;, as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ."><meta property="og:type" content="article"><meta property="og:url" content="https://yyf.zone/blogs/2022-12-21-rawsocketbindinterface/"><meta property="og:image" content="https://yyf.zone/papermod-cover.png"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2022-12-21T21:11:50+08:00"><meta property="article:modified_time" content="2022-12-21T21:11:50+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yyf.zone/papermod-cover.png"><meta name=twitter:title content="绑定RawSocket与Interface"><meta name=twitter:description content="在做以太网的回环测试时，需要实现指定MAC发送RawSocket报文，然后指定MAC接收回环过来的RawSocket报文。这就需要将socket绑定到网络接口（eth0,eth1），rawsocket的绑定方式与其他socket还不一样，研究了一下发现可以通过下面的方式实现。
从特定网络接口接收raw socket报文 如果是 AF_INET sockets 可以用 setsockopt() 来实现:
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); /* SO_BINDTODEVICE Bind this socket to a particular device like &#34;eth0&#34;, as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://yyf.zone/blogs/"},{"@type":"ListItem","position":2,"name":"绑定RawSocket与Interface","item":"https://yyf.zone/blogs/2022-12-21-rawsocketbindinterface/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"绑定RawSocket与Interface","name":"绑定RawSocket与Interface","description":"在做以太网的回环测试时，需要实现指定MAC发送RawSocket报文，然后指定MAC接收回环过来的RawSocket报文。这就需要将socket绑定到网络接口（eth0,eth1），rawsocket的绑定方式与其他socket还不一样，研究了一下发现可以通过下面的方式实现。\n从特定网络接口接收raw socket报文 如果是 AF_INET sockets 可以用 setsockopt() 来实现:\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); /* SO_BINDTODEVICE Bind this socket to a particular device like \u0026#34;eth0\u0026#34;, as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ.","keywords":["博客"],"articleBody":"在做以太网的回环测试时，需要实现指定MAC发送RawSocket报文，然后指定MAC接收回环过来的RawSocket报文。这就需要将socket绑定到网络接口（eth0,eth1），rawsocket的绑定方式与其他socket还不一样，研究了一下发现可以通过下面的方式实现。\n从特定网络接口接收raw socket报文 如果是 AF_INET sockets 可以用 setsockopt() 来实现:\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); /* SO_BINDTODEVICE Bind this socket to a particular device like \"eth0\", as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ. If a socket is bound to an interface, only packets received from that particular interface are processed by the socket. Note that this only works for some socket types, particularly AF_INET sockets. It is not supported for packet sockets (use normal bind(2) there). */ AF_PACKET sockets 需要用 bind() 实现:\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); /* By default, all packets of the specified protocol type are passed to a packet socket. To get packets only from a specific interface use bind(2) specifying an address in a struct sockaddr_ll to bind the packet socket to an interface. Fields used for binding are sll_family (should be AF_PACKET), sll_protocol, and sll_ifindex. */ 示例代码：\n#include #include #include #include #include #include #include #include #include #include #include #define MSG_LENGTH 64 bool get_mac_address(const char *if_name, struct sockaddr_ll \u0026mac) { struct ifreq ifr; int fd = socket(AF_INET, SOCK_DGRAM, 0); if (fd \u003c 0) { perror(\"socket fd create failed\"); return false; } memset(\u0026ifr, 0, sizeof(ifr)); strcpy(ifr.ifr_name, if_name); if (ioctl(fd, SIOCGIFHWADDR, \u0026ifr) \u003c 0) { perror(\"get mac address failed\"); return false; } memcpy(mac.sll_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN); close(fd); return true; } bool bind_recv_raw_socket(int sockfd, char *if_name) { struct sockaddr_ll mac_addr; if (!get_mac_address(if_name, mac_addr)) { return false; } mac_addr.sll_family = AF_PACKET; if (bind(sockfd, (struct sockaddr *)\u0026mac_addr, sizeof(mac_addr)) == -1) { perror(\"bind recv interface failed\"); return false; } return true; } int main(int argc, char *argv[]) { if (argc \u003c 2) { printf(\"argument error\\n\"); exit(EXIT_FAILURE); } int fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); if (fd == -1) { perror(\"socket init failed\"); exit(EXIT_FAILURE); } printf(argv[1]); if (!bind_recv_raw_socket(fd, argv[1])) { exit(EXIT_FAILURE); } uint8_t buff[MSG_LENGTH] = {}; while (true) { int ret = recvfrom(fd, buff, MSG_LENGTH, 0, NULL, NULL); if (ret == -1) { perror(\"recvfrom failed\"); } else { for (int i = 0; i \u003c MSG_LENGTH; ++i) { printf(\"%02X \", buff[i]); } printf(\"\\n\"); } sleep(1); } } 从特定网络接口发送raw socket报文 一般steam socket和datagram socket要实现这个功能是用 setsockopt() ，但是数据链路层的raw socket是用 sendto() 实现。\nssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); 其中最后的两个参数dest_addr、addrlen在raw socket中是冗余的，因为包是我们自己组的，不需要这两个参数提供目地地址。但是我们可以通过dest_addr中的interface index来指定网络接口发送，这就很巧妙。\n示例代码：\n#include #include #include #include #include #include #include #include #include #include #include #define MSG_LENGTH 64 int get_interface_id(char *if_name) { struct ifreq ifr; // create socket fd for ioctl operation int fd = socket(AF_INET, SOCK_DGRAM, 0); if (fd \u003c 0) { perror(\"socket fd create failed\"); return -1; } memset(\u0026ifr, 0, sizeof(ifr)); strcpy(ifr.ifr_name, if_name); if (ioctl(fd, SIOCGIFINDEX, \u0026ifr) \u003c 0) { perror(\"get interface index failed\"); return -1; } close(fd); return ifr.ifr_ifindex; } bool bind_send_raw_socket(struct sockaddr_ll \u0026dest_addr, char *if_name) { int if_idx = get_interface_id(if_name); if (if_idx == -1) { return false; } dest_addr.sll_ifindex = if_idx; return true; } int main(int argc, char *argv[]) { if (argc \u003c 2) { printf(\"argument error\\n\"); exit(EXIT_FAILURE); } int fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); if (fd == -1) { perror(\"socket init failed\"); exit(EXIT_FAILURE); } struct sockaddr_ll dest_addr; // if you use sudo, please change argv[1] to argv[2] if (!bind_send_raw_socket(dest_addr, argv[1])) { exit(EXIT_FAILURE); } uint8_t buff[MSG_LENGTH] = {0xAA, 0xBB, 0xCC, 0xDD}; while (true) { int ret = sendto(fd, buff, sizeof(buff), 0, (struct sockaddr *)\u0026dest_addr, sizeof(dest_addr)); if (ret == -1) { perror(\"send failed\"); } sleep(1); } } 总结 raw socket还是比较麻烦的，绑定到接口的方法比较不同。在以太网回环测试中，因为是一片soc上有两个mac，然后一个mac发报文，一个mac收报文。很奇怪的是我必须将收报文的mac设置为混杂模式才能收到，但是我使用的是单播，这个还得研究一下。\n","wordCount":"608","inLanguage":"cn","datePublished":"2022-12-21T21:11:50+08:00","dateModified":"2022-12-21T21:11:50+08:00","author":{"@type":"Person","name":"Ye Yunfei"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yyf.zone/blogs/2022-12-21-rawsocketbindinterface/"},"publisher":{"@type":"Organization","name":"Play With YYF","logo":{"@type":"ImageObject","url":"https://yyf.zone/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yyf.zone/ accesskey=h title="Play With YYF (Alt + H)">Play With YYF</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://yyf.zone/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yyf.zone/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://yyf.zone/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yyf.zone/>Home</a>&nbsp;»&nbsp;<a href=https://yyf.zone/blogs/></a></div><h1 class=post-title>绑定RawSocket与Interface</h1><div class=post-meta><span title='2022-12-21 21:11:50 +0800 +0800'>December 21, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Ye Yunfei</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%8e%e7%89%b9%e5%ae%9a%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3%e6%8e%a5%e6%94%b6raw-socket%e6%8a%a5%e6%96%87 aria-label="从特定网络接口接收raw socket报文">从特定网络接口接收raw socket报文</a></li><li><a href=#%e4%bb%8e%e7%89%b9%e5%ae%9a%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3%e5%8f%91%e9%80%81raw-socket%e6%8a%a5%e6%96%87 aria-label="从特定网络接口发送raw socket报文">从特定网络接口发送raw socket报文</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><p>在做以太网的回环测试时，需要实现指定MAC发送RawSocket报文，然后指定MAC接收回环过来的RawSocket报文。这就需要将socket绑定到网络接口（eth0,eth1），rawsocket的绑定方式与其他socket还不一样，研究了一下发现可以通过下面的方式实现。</p><h2 id=从特定网络接口接收raw-socket报文>从特定网络接口接收raw socket报文<a hidden class=anchor aria-hidden=true href=#从特定网络接口接收raw-socket报文>#</a></h2><p>如果是 <strong>AF_INET sockets</strong> 可以用 <strong>setsockopt()</strong> 来实现:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>setsockopt</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=kt>int</span> <span class=n>optname</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>optval</span><span class=p>,</span> <span class=n>socklen_t</span> <span class=n>optlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>SO_BINDTODEVICE
</span></span></span><span class=line><span class=cl><span class=cm>    Bind this socket to a particular device like &#34;eth0&#34;, as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ. If a socket is bound to an interface, only packets received from that particular interface are processed by the socket. Note that this only works for some socket types, particularly AF_INET sockets. It is not supported for packet sockets (use normal bind(2) there). 
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p><strong>AF_PACKET sockets</strong> 需要用 <strong>bind()</strong> 实现:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>bind</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=nc>sockaddr</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=n>socklen_t</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>By default, all packets of the specified protocol type are passed
</span></span></span><span class=line><span class=cl><span class=cm>to a packet socket.  To get packets only from a specific
</span></span></span><span class=line><span class=cl><span class=cm>interface use bind(2) specifying an address in a struct
</span></span></span><span class=line><span class=cl><span class=cm>sockaddr_ll to bind the packet socket to an interface.  Fields
</span></span></span><span class=line><span class=cl><span class=cm>used for binding are sll_family (should be AF_PACKET),
</span></span></span><span class=line><span class=cl><span class=cm>sll_protocol, and sll_ifindex.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>示例代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/if_packet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;net/ethernet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;net/if.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/ioctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MSG_LENGTH 64
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>get_mac_address</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>if_name</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>sockaddr_ll</span> <span class=o>&amp;</span><span class=n>mac</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>ifreq</span> <span class=n>ifr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_DGRAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perror</span><span class=p>(</span><span class=s>&#34;socket fd create failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ifr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ifr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>strcpy</span><span class=p>(</span><span class=n>ifr</span><span class=p>.</span><span class=n>ifr_name</span><span class=p>,</span> <span class=n>if_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>SIOCGIFHWADDR</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ifr</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perror</span><span class=p>(</span><span class=s>&#34;get mac address failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>memcpy</span><span class=p>(</span><span class=n>mac</span><span class=p>.</span><span class=n>sll_addr</span><span class=p>,</span> <span class=n>ifr</span><span class=p>.</span><span class=n>ifr_hwaddr</span><span class=p>.</span><span class=n>sa_data</span><span class=p>,</span> <span class=n>ETH_ALEN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>bind_recv_raw_socket</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>if_name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>sockaddr_ll</span> <span class=n>mac_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>get_mac_address</span><span class=p>(</span><span class=n>if_name</span><span class=p>,</span> <span class=n>mac_addr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>mac_addr</span><span class=p>.</span><span class=n>sll_family</span> <span class=o>=</span> <span class=n>AF_PACKET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>bind</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>mac_addr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>mac_addr</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perror</span><span class=p>(</span><span class=s>&#34;bind recv interface failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;argument error</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_PACKET</span><span class=p>,</span> <span class=n>SOCK_RAW</span><span class=p>,</span> <span class=n>htons</span><span class=p>(</span><span class=n>ETH_P_ALL</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perror</span><span class=p>(</span><span class=s>&#34;socket init failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bind_recv_raw_socket</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=n>buff</span><span class=p>[</span><span class=n>MSG_LENGTH</span><span class=p>]</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>recvfrom</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buff</span><span class=p>,</span> <span class=n>MSG_LENGTH</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>perror</span><span class=p>(</span><span class=s>&#34;recvfrom failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>MSG_LENGTH</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%02X &#34;</span><span class=p>,</span> <span class=n>buff</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=从特定网络接口发送raw-socket报文>从特定网络接口发送raw socket报文<a hidden class=anchor aria-hidden=true href=#从特定网络接口发送raw-socket报文>#</a></h2><p>一般steam socket和datagram socket要实现这个功能是用 <strong>setsockopt()</strong> ，但是数据链路层的raw socket是用 <strong>sendto()</strong> 实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ssize_t</span> <span class=nf>sendto</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=nc>sockaddr</span> <span class=o>*</span><span class=n>dest_addr</span><span class=p>,</span> <span class=n>socklen_t</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span></code></pre></div><p>其中最后的两个参数dest_addr、addrlen在raw socket中是冗余的，因为包是我们自己组的，不需要这两个参数提供目地地址。但是我们可以通过dest_addr中的interface index来指定网络接口发送，这就很巧妙。<br>示例代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/if_packet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;net/ethernet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;net/if.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/ioctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MSG_LENGTH 64
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_interface_id</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>if_name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>ifreq</span> <span class=n>ifr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// create socket fd for ioctl operation
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>SOCK_DGRAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perror</span><span class=p>(</span><span class=s>&#34;socket fd create failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ifr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ifr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>strcpy</span><span class=p>(</span><span class=n>ifr</span><span class=p>.</span><span class=n>ifr_name</span><span class=p>,</span> <span class=n>if_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>SIOCGIFINDEX</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ifr</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perror</span><span class=p>(</span><span class=s>&#34;get interface index failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ifr</span><span class=p>.</span><span class=n>ifr_ifindex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>bind_send_raw_socket</span><span class=p>(</span><span class=k>struct</span> <span class=nc>sockaddr_ll</span> <span class=o>&amp;</span><span class=n>dest_addr</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>if_name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>if_idx</span> <span class=o>=</span> <span class=n>get_interface_id</span><span class=p>(</span><span class=n>if_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>if_idx</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>dest_addr</span><span class=p>.</span><span class=n>sll_ifindex</span> <span class=o>=</span> <span class=n>if_idx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;argument error</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>AF_PACKET</span><span class=p>,</span> <span class=n>SOCK_RAW</span><span class=p>,</span> <span class=n>htons</span><span class=p>(</span><span class=n>ETH_P_ALL</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>perror</span><span class=p>(</span><span class=s>&#34;socket init failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>sockaddr_ll</span> <span class=n>dest_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// if you use sudo, please change argv[1] to argv[2]
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bind_send_raw_socket</span><span class=p>(</span><span class=n>dest_addr</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=n>buff</span><span class=p>[</span><span class=n>MSG_LENGTH</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mh>0xAA</span><span class=p>,</span> <span class=mh>0xBB</span><span class=p>,</span> <span class=mh>0xCC</span><span class=p>,</span> <span class=mh>0xDD</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>sendto</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buff</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buff</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>dest_addr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>sizeof</span><span class=p>(</span><span class=n>dest_addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>perror</span><span class=p>(</span><span class=s>&#34;send failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>raw socket还是比较麻烦的，绑定到接口的方法比较不同。在以太网回环测试中，因为是一片soc上有两个mac，然后一个mac发报文，一个mac收报文。很奇怪的是我必须将收报文的mac设置为混杂模式才能收到，但是我使用的是单播，这个还得研究一下。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yyf.zone/tags/%E5%8D%9A%E5%AE%A2/>博客</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://yyf.zone/>Play With YYF</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>