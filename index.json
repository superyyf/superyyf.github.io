[{"content":"在做以太网的回环测试时，需要实现指定MAC发送RawSocket报文，然后指定MAC接收回环过来的RawSocket报文。这就需要将socket绑定到网络接口（eth0,eth1），rawsocket的绑定方式与其他socket还不一样，研究了一下发现可以通过下面的方式实现。\n从特定网络接口接收raw socket报文 如果是 AF_INET sockets 可以用 setsockopt() 来实现:\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); /* SO_BINDTODEVICE Bind this socket to a particular device like \u0026#34;eth0\u0026#34;, as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ. If a socket is bound to an interface, only packets received from that particular interface are processed by the socket. Note that this only works for some socket types, particularly AF_INET sockets. It is not supported for packet sockets (use normal bind(2) there). */ AF_PACKET sockets 需要用 bind() 实现:\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); /* By default, all packets of the specified protocol type are passed to a packet socket. To get packets only from a specific interface use bind(2) specifying an address in a struct sockaddr_ll to bind the packet socket to an interface. Fields used for binding are sll_family (should be AF_PACKET), sll_protocol, and sll_ifindex. */ 示例代码：\n#include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;linux/if_packet.h\u0026gt; #include \u0026lt;net/ethernet.h\u0026gt; #include \u0026lt;net/if.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define MSG_LENGTH 64 bool get_mac_address(const char *if_name, struct sockaddr_ll \u0026amp;mac) { struct ifreq ifr; int fd = socket(AF_INET, SOCK_DGRAM, 0); if (fd \u0026lt; 0) { perror(\u0026#34;socket fd create failed\u0026#34;); return false; } memset(\u0026amp;ifr, 0, sizeof(ifr)); strcpy(ifr.ifr_name, if_name); if (ioctl(fd, SIOCGIFHWADDR, \u0026amp;ifr) \u0026lt; 0) { perror(\u0026#34;get mac address failed\u0026#34;); return false; } memcpy(mac.sll_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN); close(fd); return true; } bool bind_recv_raw_socket(int sockfd, char *if_name) { struct sockaddr_ll mac_addr; if (!get_mac_address(if_name, mac_addr)) { return false; } mac_addr.sll_family = AF_PACKET; if (bind(sockfd, (struct sockaddr *)\u0026amp;mac_addr, sizeof(mac_addr)) == -1) { perror(\u0026#34;bind recv interface failed\u0026#34;); return false; } return true; } int main(int argc, char *argv[]) { if (argc \u0026lt; 2) { printf(\u0026#34;argument error\\n\u0026#34;); exit(EXIT_FAILURE); } int fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); if (fd == -1) { perror(\u0026#34;socket init failed\u0026#34;); exit(EXIT_FAILURE); } printf(argv[1]); if (!bind_recv_raw_socket(fd, argv[1])) { exit(EXIT_FAILURE); } uint8_t buff[MSG_LENGTH] = {}; while (true) { int ret = recvfrom(fd, buff, MSG_LENGTH, 0, NULL, NULL); if (ret == -1) { perror(\u0026#34;recvfrom failed\u0026#34;); } else { for (int i = 0; i \u0026lt; MSG_LENGTH; ++i) { printf(\u0026#34;%02X \u0026#34;, buff[i]); } printf(\u0026#34;\\n\u0026#34;); } sleep(1); } } 从特定网络接口发送raw socket报文 一般steam socket和datagram socket要实现这个功能是用 setsockopt() ，但是数据链路层的raw socket是用 sendto() 实现。\nssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); 其中最后的两个参数dest_addr、addrlen在raw socket中是冗余的，因为包是我们自己组的，不需要这两个参数提供目地地址。但是我们可以通过dest_addr中的interface index来指定网络接口发送，这就很巧妙。\n示例代码：\n#include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;linux/if_packet.h\u0026gt; #include \u0026lt;net/ethernet.h\u0026gt; #include \u0026lt;net/if.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define MSG_LENGTH 64 int get_interface_id(char *if_name) { struct ifreq ifr; // create socket fd for ioctl operation int fd = socket(AF_INET, SOCK_DGRAM, 0); if (fd \u0026lt; 0) { perror(\u0026#34;socket fd create failed\u0026#34;); return -1; } memset(\u0026amp;ifr, 0, sizeof(ifr)); strcpy(ifr.ifr_name, if_name); if (ioctl(fd, SIOCGIFINDEX, \u0026amp;ifr) \u0026lt; 0) { perror(\u0026#34;get interface index failed\u0026#34;); return -1; } close(fd); return ifr.ifr_ifindex; } bool bind_send_raw_socket(struct sockaddr_ll \u0026amp;dest_addr, char *if_name) { int if_idx = get_interface_id(if_name); if (if_idx == -1) { return false; } dest_addr.sll_ifindex = if_idx; return true; } int main(int argc, char *argv[]) { if (argc \u0026lt; 2) { printf(\u0026#34;argument error\\n\u0026#34;); exit(EXIT_FAILURE); } int fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); if (fd == -1) { perror(\u0026#34;socket init failed\u0026#34;); exit(EXIT_FAILURE); } struct sockaddr_ll dest_addr; // if you use sudo, please change argv[1] to argv[2] if (!bind_send_raw_socket(dest_addr, argv[1])) { exit(EXIT_FAILURE); } uint8_t buff[MSG_LENGTH] = {0xAA, 0xBB, 0xCC, 0xDD}; while (true) { int ret = sendto(fd, buff, sizeof(buff), 0, (struct sockaddr *)\u0026amp;dest_addr, sizeof(dest_addr)); if (ret == -1) { perror(\u0026#34;send failed\u0026#34;); } sleep(1); } } 总结 raw socket还是比较麻烦的，绑定到接口的方法比较不同。在以太网回环测试中，因为是一片soc上有两个mac，然后一个mac发报文，一个mac收报文。很奇怪的是我必须将收报文的mac设置为混杂模式才能收到，但是我使用的是单播，这个还得研究一下。\n","permalink":"https://yyf.zone/blogs/2022-12-21-rawsocketbindinterface/","summary":"\u003cp\u003e在做以太网的回环测试时，需要实现指定MAC发送RawSocket报文，然后指定MAC接收回环过来的RawSocket报文。这就需要将socket绑定到网络接口（eth0,eth1），rawsocket的绑定方式与其他socket还不一样，研究了一下发现可以通过下面的方式实现。\u003c/p\u003e","title":"绑定RawSocket与Interface"},{"content":"强制类型转换 C风格强制类型转换 形式：$Type \\quad b = (Type) \\quad a$ 缺点：没有统一的关键字和标示符。错误难以排查。 const_cast 常量指针被转化成非常量的指针； 常量引用被转换成非常量的引用。 唯一可以实现去const功能的类型转换符。 static_cast 与C风格的转换效果类似，用于基本数据类型之间的转换。 用于基类和派生类之间的指针或引用的转换时， 向上转换（派生类\u0026mdash;-\u0026gt;基类）是安全的； 向下转换（基类\u0026mdash;-\u0026gt;派生类）由于没有动态类型检查，所以是不安全的。 据说C++的隐式转换都是使用static_cast来实现的。 dynamic_cast 用于类层次间的向上转换或向下转换，还可以用于类之间的交叉转换。 向上转换时，效果和static_cast一样； 向下转换时具有类型检查的功能，对于不安全的指针转换，转换结果返回NULL指针。 只有该类具有虚函数时，才能进行这种转换。 reinterpret_cast 重新解释对象的比特模型，从底层对数据进行重新解释。 可以实现任意指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换。 体现了 C++ 语言的设计思想：用户可以做任何操作，但要为自己的行为负责。 非常危险的操作，慎重使用。 总结 去const属性用 const_cast 基本类型转换用static_cast 多态类之间的类型转换用dynamic_cast 不同类型的指针类型转换用reinterpret_cast 参考：\n叶余的博客 ydar95的博客 evenleo的博客 ","permalink":"https://yyf.zone/notes/2021-8-5-typecast/","summary":"\u003ch1 id=\"强制类型转换\"\u003e强制类型转换\u003c/h1\u003e","title":"强制类型转换"},{"content":"一篇搞定static, extern static的作用 c/c++中的修饰符，用来控制变量的存储方式和可见性。 当修饰局部变量时，变量在内存中的存储区域变成静态存储区（BSS段、DATA段），生存周期变成整个程序的生存周期。 修饰全局变量和函数时，其作用域的范围由原来的整个工程可见变为本源文件可见。这样就不会跟其他文件中相同名字的变量冲突 静态全局变量 存储位置：不变。 生命周期：不变。 可见性：整个工程可见\u0026mdash;-\u0026gt;当前文件可见。（即使加extern也不行） 若未显式初始化，则程序自动初始化为0。 静态局部变量 存储位置：栈区\u0026mdash;-\u0026gt;静态数据区。 生命周期：语句块\u0026mdash;-\u0026gt;整个程序。 可见性：不变。 静态局部变量只初始化一次，再次初始化时不执行。 若未显式初始化，则程序自动初始化为0。 静态函数 同静态全局变量，只改变可见性。 静态成员变量和静态成员函数 static修饰成员函数时，表示该函数属于一个类而不是属于此类的任何特定对象。 static修饰成员变量时，表示该变量为类以及其所有的对象所有。 它们在存储空间中都只存在一个副本。可以通过类和对象去调用。 类的静态成员变量必须先初始化再使用，且只能在类体外进行初始化。 对于静态成员函数，只能访问静态成员函数和静态成员变量，不能访问非静态成员函数或者变量。 extern extern修饰变量和函数时，表示该变量和函数在别的文件中定义。 \u0026ldquo;extern C\u0026quot;会告诉编译器这个函数按照C的规则编译。 参考：\nrunoob Matrix海子博客 小德cyj博客 ","permalink":"https://yyf.zone/notes/2021-8-5-staticextern/","summary":"\u003ch1 id=\"一篇搞定static-extern\"\u003e一篇搞定static, extern\u003c/h1\u003e","title":"一篇搞定static, extern"},{"content":"目录 目录层次结构\n一级目录系统 层次目录系统 路径名\n绝对路径：它由从根目录到文件的路径组成。如果路径名的第一个字符是分隔符，则这个路径就是绝对路径。\n相对路径：它常和工作目录（也称作当前目录）一起使用。所有不从根目录开始的路径名都是相对于工作目录的。\n两个特殊的目录项\n\u0026ldquo;.\u0026quot;：当前目录\n\u0026ldquo;..\u0026quot;：父目录\n目录操作\ncreate。创建目录。 delete。删除目录。只有空目录可删除。 opendir。目录内容可被读取。 closedir。关闭目录以释放内部表空间。 readdir。返回打开目录的下一个目录项。 rename。重命名。 link。链接技术允许在多个目录中出现同一个文件。 unlink。删除目录项。 链接\n硬链接：链接文件和原文件的inode值一样，也就是它们的i节点相同，i节点类似智能指针，指向物理硬盘的一个区块，i节点会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。所以删除原文件不会对链接文件产生影响。 软链接：链接文件和原文件的inode值不同，软链接文件的inode指向的内容实际上是保存了一个绝对路径，当用户访问这个文件时，系统会自动将其替换成其所指向的文件路径。所有删除原文件会使软链接文件失效。 参考：\n《现代操作系统》 博客 ","permalink":"https://yyf.zone/notes/2021-8-4-directory/","summary":"\u003ch1 id=\"目录\"\u003e目录\u003c/h1\u003e","title":"目录"},{"content":"文件 为什么要有文件这种东西？ 使用信息的进程终止时，信息仍旧存在； 能够使多个线程并发访问有关信息； 能够存储大量的信息。 什么是文件？ 文件是进程创建的信息逻辑单元。 文件的命名 文件的具体命名规则在各个系统中是不同的。 UNIX系统中区分大小写字母，MS-DOS系统则不区分。 UNIX系统中文件拓展名只是一种约定，操作系统并不强迫采用它，Windows系统则关注拓展名并对其赋予了含义。 文件结构 把文件看成字节序列为操作系统提供了最大的灵活性。UNIX和WIndows都采用这种文件模型。 文件类型(UNIX为例)\n普通文件：包含有用户信息的文件。 - ASCII文件：文本。 - 二进制文件：有一定的内部结构，如可执行文件、存档文件。 字符特殊文件：和输入输出有关，用于串行I/O设备，如终端、打印机、网络等。 块特殊文件：用于磁盘类设备。 目录：管理文件系统结构的系统文件。\n文件访问\n顺序访问：磁带。 随机访问：磁盘。 文件属性 属性 含义 保护 谁可以访问文件，以什么方式存取文件 口令 访问文件需要的口令 创建者 创建文件者的ID 所有者 当前所有者 只读标志 0表示读/写；1表示只读 隐藏标志 0表示正常；1表示不在列表中显示 系统标志 0表示普通文件；1表示系统文件 存档标志 0表示已经备份；1表示需要备份 ASCII/二进制标志 0表示ASCII码文件；1表示二进制文件 随机访问标志 0表示允许顺序访问；1表示随机访问 临时标志 0表示正常；1表示进程退出时删除该文件 加锁标志 0表示未加锁，非0表示加锁 记录长度 一个记录中的字节数 键的位置 每个记录中键的偏移量 键的长度 键字段的字节数 创建时间 创建文件的日期和时间 最后一次存取时间 上一次访问文件的时间 最后一次修改时间 上一次修改文件的时间 当前大小 文件的字节数 最大长度 文件可能增长的字节数 文件操作 create。创建不包含任何数据的文件。 delete。删除文件。 open。把文件属性和磁盘地址表装入内存。 close。关闭文件以释放内部表空间。 read。在文件中读取数据。 write。向文件写数据。 append。在文件末尾添加数据。 seek。把当前位置指针指向文件中特定的位置。 get_attributes。读取文件属性。 set_attribute。设置文件属性。 rename。重命名。 参考：《现代操作系统》\n","permalink":"https://yyf.zone/notes/2021-8-3-file/","summary":"\u003ch1 id=\"文件\"\u003e文件\u003c/h1\u003e","title":"文件"},{"content":"二分查找 Tips 搜索空间可以选择左闭右开区间，或者两端都闭区间。 注意搜索空间的变化，while的终止条件要和搜索空间对应。 如果搜索左右边界，只要在input[mid]==target时，改变搜索空间即可。 代码实现 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; //无重复元素 //返回目标值的下标，没有目标值返回-1 int binarySearch_basic(const vector\u0026lt;int\u0026gt;\u0026amp; input, int target) { //搜索空间为两端都闭区间：[left, right] int left = 0; int right = input.size() - 1; //终止条件为left\u0026lt;=right,即当left\u0026gt;right时退出循环 //终止条件要和搜索空间对应，[right, left]为空 while (left \u0026lt;= right) { int mid = (left + right) / 2; if (input[mid] == target) return mid; //搜索空间变为[mid+1, right] else if (input[mid] \u0026lt; target) left = mid + 1; //搜索空间变为[left, mid-1] else if (input[mid] \u0026gt; target) right = mid - 1; } return -1; } //有重复元素，查找目标值的左边界 int binarySearch_left_bound(const vector\u0026lt;int\u0026gt;\u0026amp; input, int target) { //搜索空间为左闭右开区间：[left,right) int left = 0; int right = input.size(); //终止条件为left \u0026lt; right，即当left == right时退出循环 //[left,left)为空 while (left \u0026lt; right) { int mid = (left + right) / 2; //由于寻找的是目标值的左边界，所有当mid处的值等于target时向左搜索 //搜索空间为[left,mid) if (input[mid] == target) right = mid; //搜索空间变为[mid+1,right) else if (input[mid] \u0026lt; target) left = mid + 1; //搜索空间变为[left,mid) else if (input[mid] \u0026lt; target) right = mid; } //当退出循环时left==right，搜索空间为[left,left) //left下标就是目标值的左边界 if (left == input.size())return -1; return input[left] == target ? left : -1; } //有重复元素，查找目标值的右边界 int binarySearch_right_bound(const vector\u0026lt;int\u0026gt;\u0026amp; input, int target) { //[left,right) int left = 0; int right = input.size(); //[left,left) while (left \u0026lt; right) { int mid = (left + right) / 2; //[mid+1,right) if (input[mid] == target) left = mid + 1; //[mid+1,right) else if (input[mid] \u0026lt; target) left = mid + 1; //[left,mid) else if (input[mid] \u0026gt; target) right = mid; } if (left == input.size())return -1; return input[left - 1] == target ? left - 1 : -1; } int main() { vector\u0026lt;int\u0026gt; input = {1,2,2,2,2,3,4,5}; int target = 2; cout \u0026lt;\u0026lt; \u0026#34;basic: \u0026#34; \u0026lt;\u0026lt; binarySearch_basic(input, target) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;left bound: \u0026#34; \u0026lt;\u0026lt; binarySearch_left_bound(input, target) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;right bound: \u0026#34; \u0026lt;\u0026lt; binarySearch_right_bound(input, target) \u0026lt;\u0026lt; endl; } 参考：murphy_gb的博客\n","permalink":"https://yyf.zone/notes/2021-8-3-binarysearch/","summary":"\u003ch1 id=\"二分查找\"\u003e二分查找\u003c/h1\u003e","title":"二分查找的简单总结"},{"content":"AVL树、红黑树、B树和B+树 基本概念 二叉搜索树 左节点 \u0026lt; 根节点 \u0026lt; 右节点 每一个子树都是二叉搜索树 平衡二叉树（AVL树） 左右子树的高度差 \u0026lt;= 1 每一个子树都是平衡二叉树 平衡二叉树的优势 快速查找(log(n)) AVL树（平衡二叉树） 维持平衡的方法 高度 每个节点引入高度属性，即左右子树的高度的最大值。 在插入和删除节点时，沿插入和删除的路径更新节点的高度值。 平衡因子 左子树和右子树的高度差值。 当高度差值\u0026gt;1时，会触发树的旋转。 旋转（再平衡操作） 在插入和删除的路径上，从失去平衡的最小子树的根节点开始旋转。 左旋 右旋 总结 树的高度\n$$h = [log(n)]+1$$ 优缺点 严格的平衡二叉树（左右子树高度差不超过1），查找效率很高 再平衡代价高，每个节点需要多保存一个数，旋转操作复杂，所以插入、删除效率一般。 红黑树 维持平衡的方法 每个节点要么是黑色，要么是红色。 根节点是黑色。叶子节点(NULL)也是黑色。 如果一个节点是红色，那么它的子节点必须是黑色。（没有连续的红节点） 对于每个节点，从该节点到其子孙节点的所有路径上包含相同的黑节点数。 插入和删除（再平衡操作） 插入操作 若树为空，则将插入节点作为根节点，着黑色。 若树不为空，插入节点总是红色，若其父节点是黑色，则不需要操作。否则并两种情况： 其父节点是红色，并且其父节点的兄弟节点也是红色，则将其父节点和其父节点的兄弟节点着黑色。并递归的操作其祖父节点。 其父节点是红色，其父节点的兄弟节点是黑色，则做旋转并重新着色。 黑色高度：节点到叶子节点(NULL)经过的黑色节点数。 总结 树的高度\n$$ h \u0026lt;= 2log(n+1) $$ 优缺点 非严格的平衡二叉树，查找效率略低于AVL树。 再平衡操作代价较低，每个节点只需要多保存一个bit，插入、删除效率高于AVL树。 B树 特点 B树是多路平衡查找树 对于m阶B树 根节点的关键字（键值对）数量范围：$1\u0026lt;=k\u0026lt;=m-1$ 非根节点的关键字（键值对）数量范围：$m/2\u0026lt;=k\u0026lt;=m-1$ 每个节点的关键字升序排列，每个关键字的左子树中的所有关键字都小于它，右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 插入和删除（再平衡操作） 插入 判断插入后，当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，根据节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。 删除 删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点。 对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。 总结 B树/B+树是磁盘友好的数据结构 IO次数少 查询效率稳定 遍历方便 红黑树多用于内部排序 B+树 与B树的不同点 数据只存储在叶子节点，非叶子节点（内部节点）只负责索引。 父节点存有右孩子的第一个元素的索引。 每个叶子节点都存有相邻叶子节点的指针。 插入和删除（再平衡操作） 插入 当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的。 删除 对于删除操作是比B树简单一些的，因为叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key。 与B树相比的优点 单个节点存储的元素更多，查找效率更高。 所有查找都要搜索到叶子节点，性能稳定。 所有的叶子节点形成了一个有序链表，遍历效率高。 ","permalink":"https://yyf.zone/notes/2021-7-25-tree/","summary":"\u003ch1 id=\"avl树红黑树b树和b树\"\u003eAVL树、红黑树、B树和B+树\u003c/h1\u003e","title":"AVL树、红黑树、B树和B+树"},{"content":"地址空间和交换技术 地址空间 定义 地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间。\n为什么要引入地址空间？ 如何没有将物理地址抽象，用户会很容易的破坏操作系统 可以同时运行多个进程 地址空间需要解决的问题？ 动态重定位。 将每个进程的地址空间映射到物理内存的不同部分。比较经典的方法是使用基址寄存器和界限寄存器。 当一个进程运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。 每次进程访问内存前，CPU会在发送地址到内存总线前，自动把基址值加到进程的地址值上。同时检查进程提供的地址是否等于或大于界限寄存器里的值。如果超过会产生错误并中止访问。 这种方法很简单，但是运行速度很慢。因为要做加法运算。 内存超载。 交换技术 虚拟内存 交换技术 定义 把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。\n涉及的问题 交换在内存中产生了多个空闲区（空洞）。 通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块。该技术成为内存紧缩。 内存紧缩用的较少，因为费时。 为进程分配多大的内存。 由于进程的数据段可以增长。当换入或移动进程时为它分配一些额外的内存。 如果内存用完必须移动到足够大的空闲区（或换出内存直到有足够的空间），或者结束进程。 空闲内存如何管理。 使用位图跟踪内存的使用情况。使用位图方法时，内存可能被划分为不等大小的分配单元。每个分配单元对应位图中的一位，0表示空闲，1表示占用（或者相反）。 使用链表跟踪内存使用情况。链表中的一个结点或者包含一个进程，或者是两个进程的一块空闲区。结点包含以下域：空闲区或进程的指示标志、起始地址、长度和下一结点的指针。 当按照地址顺序在链表中存放进程和空闲区时，有以下几种算法为创建的进程分配内存。首次适配、下次适配、最佳适配、最差适配、快速适配。 参考《现代操作系统》\n","permalink":"https://yyf.zone/notes/2021-7-2-addressspace/","summary":"\u003ch1 id=\"地址空间和交换技术\"\u003e地址空间和交换技术\u003c/h1\u003e","title":"地址空间和交换技术"},{"content":"二叉树的遍历-中序遍历 二叉树的结构 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ 递归方式 递归方式比较简单：按左-\u0026gt;中-\u0026gt;右的顺序操作。\n时间复杂度：$O(n)$，$n$为二叉树的结点的个数。二叉树中的每个结点都被访问了一次。\n空间复杂度：$O(n)$，空间复杂度取决于树的深度，在最坏情况下树的深度等于结点个数。\nclass Solution { public: void dfs(TreeNode* node, vector\u0026lt;int\u0026gt;\u0026amp; vint){ if(node == nullptr){ return; } //左子树 dfs(node-\u0026gt;left, vint); //对根节点的操作 vint.push_back(node-\u0026gt;val); //右子树 dfs(node-\u0026gt;right, vint); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; vint; dfs(root, vint); return vint; } }; 迭代方式 迭代的方法需要我们自己用栈来模拟递归。递归的调用过程是不断往左边走，当左边走不下去了，就打印节点，并转向右边，然后右边继续这个过程。\n时间复杂度和空间复杂度都跟递归一样。\nclass Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; ret; stack\u0026lt;TreeNode*\u0026gt; stk; while(root!= nullptr || !stk.empty()){ //不断往左子树方向走,并将结点推出栈中。 while(root != nullptr){ stk.push(root); root = root-\u0026gt;left; } //走不通了以后，保存结点数据，转向右子树。 //重复上述操作。 root = stk.top(); stk.pop(); ret.push_back(root-\u0026gt;val); root = root-\u0026gt;right; } return ret; } }; 莫里斯遍历 将二叉树转换成链表，然后依次遍历。\n优点：空间复杂度只有$O(1)$。 每个结点被访问两次，所以时间复杂度还是$O(n)$\nclass Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; TreeNode *predecessor = nullptr; while (root != nullptr) { if (root-\u0026gt;left != nullptr) { // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止 predecessor = root-\u0026gt;left; while (predecessor-\u0026gt;right != nullptr \u0026amp;\u0026amp; predecessor-\u0026gt;right != root) { predecessor = predecessor-\u0026gt;right; } // 让 predecessor 的右指针指向 root，继续遍历左子树 if (predecessor-\u0026gt;right == nullptr) { predecessor-\u0026gt;right = root; root = root-\u0026gt;left; } // 说明左子树已经访问完了，我们需要断开链接 else { res.push_back(root-\u0026gt;val); predecessor-\u0026gt;right = nullptr; root = root-\u0026gt;right; } } // 如果没有左孩子，则直接访问右孩子 else { res.push_back(root-\u0026gt;val); root = root-\u0026gt;right; } } return res; } }; 参考：leetcode 94题\n","permalink":"https://yyf.zone/notes/2021-7-1-inodertraversal/","summary":"\u003ch1 id=\"二叉树的遍历-中序遍历\"\u003e二叉树的遍历-中序遍历\u003c/h1\u003e","title":"二叉树的遍历-中序遍历"},{"content":"操作系统(Part 2) 什么是线程同步，线程同步的方式有哪些？ 线程同步就是线程有序的访问共享资源。\n互斥锁：\n(1) 每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。\n读写锁：\n(1) 写独占，读共享。\n(2) 读锁、写锁并行阻塞，写锁优先级高。 读写锁非常适合于对数据结构读的次数远大于写的情况。\n信号量(semaphore)：\n(1) 信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。\n(2) 当信号量值大于0时，则可以访问，否则将阻塞。PV原语是对信号量的操作，一次P操作使信号量减１，一次V操作使信号量加１。\n条件变量\n(1) 条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。\n(2) 保证在任何时候都只有一个线程在等待条件满足，并且当条件满足后等待的线程会收到通知，而不必轮询，同时释放锁。条件变量就是减少竞争，在条件满足后就去唤醒等待的线程\n什么是死锁？死锁产生的条件？如何处理死锁？ 两个或多个进程无限期的阻塞、相互等待的一种状态。\n死锁产生的条件：\n互斥条件：一个资源一次只能被一个进程使用。 占用并等待条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。 不可抢占条件：进程获得的资源，在未完全使用完之前，不能强行剥夺。 环路等待条件：若干进程之间形成一种头尾相接的环形等待资源关系。 处理死锁的方法：\n忽略死锁。（鸵鸟算法）\n检测死锁+恢复死锁：\n检测死锁的方法： 如果每种资源只有一个，那么可以构建资源分配图（有向图），检测其中是否有环。 检测有向图环路的算法：对每个节点进行深度优先搜索，如果碰到已经遇到多的节点则有环。 如何每种资源有多个，可以通过基于向量的比较进行死锁检测，通过比较每个进程的请求资源向量和可用资源向量来判断这个进程能否完成。 恢复死锁的方法： 利用抢占恢复 利用回滚恢复：将死锁进程回滚到持有资源之间的时间点。 通过杀死进程恢复 避免死锁\n安全状态的概念： 如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 避免死锁的调度算法： 银行家算法：算法要做的是判断对请求的满足是否会导致进入不安全状态。 在运行前就要知道所需资源的最大值，而且现实中进程数也不是固定的，所以这种方法不实用。 预防死锁\n破坏条件 处理方法 互斥 一切都使用假脱机技术 占有和等待 在开始时就请求全部资源 不可抢占 利用虚拟化技术等，允许抢占资源 环路等待 对资源按序编号，按照编号的升序请求资源 一些专用方法： 数据库死锁：两阶段加锁。第一阶段，试图对所有所需的记录进行加锁，一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新后释放。 通信死锁：超时策略。 活锁的概念：进程没有被阻塞，而是一直重复尝试，失败，尝试，失败\u0026hellip;\u0026hellip; 活锁有可能自行解开，死锁则不能。 饥饿的概念：尽管没有被阻塞，但是由于优先级的问题，一直在等待。 参考：《现代操作系统》\n","permalink":"https://yyf.zone/notes/2021-6-30-ospart2/","summary":"\u003ch1 id=\"操作系统part-2\"\u003e操作系统(Part 2)\u003c/h1\u003e","title":"操作系统面经(Part 2)"},{"content":"面经整理/操作系统（part 1）\n操作系统(Part 1) 什么是操作系统？ 操作系统是一种软件，具有以下的功能：\n屏蔽硬件，为用户和其他软件提供接口。 管理资源，合理的分配和调度资源。 什么是用户态和内核态？ 在用户态下，CPU只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。 在内核态下，CPU可以访问任意的数据，允许访问外围设备，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用CPU不会发生抢占情况，一般处于特权级0的状态我们称之为内核态。 用户态和内核态是如何切换的？ 从用户态到内核态切换可以通过三种方式：\n系统调用（软中断）。 外设中断（硬中断）。 异常。如果当前进程运行在用户态，这时候发生了异常事件就会触发切换。 请分别简单说一说进程和线程以及它们的区别。 进程：进程是资源分配与调度的基本单位，具有一定独立功能的程序的一次实例。\n线程：线程是程序执行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 区别：\n进程是资源分配的基本单位；线程是程序执行的基本单位。 进程拥有自己的资源空间，没启动一个进程，系统就会为它分配地址空间；而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。 一个进程可以包含若干个线程。 进程的通信方式有哪些？ 管道：\n(1) 匿名管道（pipe）：fork产生的子进程会继承父进程对应的文件描述符。利用这个特性，父进程先pipe创建管道之后，子进程也会得到同一个管道的读写文件描述符。从而实现了父子两个进程使用一个管道完成半双工通信。\n(2) 命名管道（fifo）：命名管道在底层的实现跟匿名管道完全一致，区别只是命名管道会有一个全局可见的文件名以供其他进程使用。\n消息队列（message）：\n(1) 消息队列传递的数据具有某种结构，而不是简单的字节流。\n(2) 消息队列的本质其实是一个内核提供的链表。\n共享内存（shared memory）：\n(1) 共享内存在各种进程间通信方式中具有最高的效率。\n(2) 共享内存允许两个或更多进程访问同一块内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。\n(3) 使用共享内存要注意的是多个进程之间对一个给定存储区访问的互斥。若一个进程正在向共享内存区写数据，则在它做完这一步操作前，别的进程不应当去读、写这些数据。\n信号量： (1) 信号量是解决互斥共享资源的同步问题而引入的机制。\nsocket： (1) socket是基于TCP或UDP协议实现的。流套接字将TCP作为其端对端协议，提供了一个可信赖的字节流服务。数据报套接字使用UDP协议，提供数据打包发送服务。\n","permalink":"https://yyf.zone/notes/2021-6-28-ospart1/","summary":"\u003cp\u003e面经整理/操作系统（part 1）\u003c/p\u003e","title":"操作系统面经(Part 1)"},{"content":"图像匹配/经典算法/RANSAC算法\n概念 随机采样一致性算法(RANdom SAmple Consensus,RANSAC)是从一组含有“外点”(outliers)的数据中正确估计数学模型参数的迭代算法。“外点”一般指的的数据中的噪声，比如说匹配中的误匹配和估计曲线中的离群点。所以，RANSAC也是一种“外点”检测算法。RANSAC是一个非确定性算法，在某种意义上说，它会产生一个在一定概率下合理的结果，其允许使用更多次的迭代来使其概率增加。\n算法内容 给定涉及参数$\\vec x$的模型拟合问题。\n假设： 模型可以通过$N$个数据项完成拟合。 总共有$M$个数据项。 随机选择的数据项成为良好模型的一部分的概率为$p_g$。 如果存在一个良好的拟合结果，但是算法没有找到就退出了的概率是$p_{fail}$。 算法： 随机选择$N$个数据项。 估计参数$\\vec x$。 找出在用户给定的容错范围内，有多少数据项符合参数向量$\\vec x$的模型，记为$K$。 如果$K$足够大，接收拟合结果并退出。 重复步骤1~4$L$次。 如果你到了这里就失败了。 $K$的大小取决于你认为属于适合的模型结构的数据的百分比以及图像中有多少个模型结构。如果存在多个模型结构，那么在成功拟合之后，删除匹配数据并重新RANSAC。\n$L$的计算方法如下：\n$$L=\\frac {log(p_{fail})}{log(1-(p_g)^N)}$$\n参考文献： M. A. Fischler, R. C. Bolles. Random Sample Consensus: A Paradigm for Model Fitting with Applications to Image Analysis and Automated Cartography. Comm. of the ACM, Vol 24, pp 381-395, 1981.\n代码实现 利用opencv实现简单的直线拟合\n#include \u0026lt;opencv2/opencv.hpp\u0026gt; /*利用RANSAC算法进行直线拟合*/ void fitLineUseRANSAC(const std::vector\u0026lt;cv::Point2f\u0026gt;\u0026amp; points, cv::Vec4f\u0026amp; line, unsigned int iteration, double sigma) { unsigned int n = points.size(); if (n \u0026lt; 2) { return; } cv::RNG rng; double bestScore = -1.; for (int i = 0; i \u0026lt; iteration; i++) { unsigned int a = 0, b = 0; while (a == b) { a = rng(n); b = rng(n); } cv::Point2f p1 = points[a]; cv::Point2f p2 = points[b]; cv::Point2f dv = p2 - p1;//方向向量 dv *= double(1) / cv::norm(dv);//标准化 double score = 0; for (int i = 0; i \u0026lt; n; i++) { cv::Point2f v = points[i] - p1; double d = v.y * dv.x - v.x * dv.y;//向量a与b叉乘,共线为0 if (fabs(d) \u0026lt; sigma) score += 1; } if (score \u0026gt; bestScore) { line = cv::Vec4f(dv.x, dv.y, p1.x, p1.y); bestScore = score; } } } /*生成测试数据集*/ void generateRandPointSet(unsigned int row, unsigned int col, std::vector\u0026lt;cv::Point2f\u0026gt;\u0026amp; points) { int k = 1; int b = 100; for (int i = 0; i \u0026lt; 500; i += 10) { cv::Point2f point(int((i - b) / k), i); points.emplace_back(point); } //加入直线的随机噪声 cv::RNG rng((unsigned)time(NULL)); for (int i = 0; i \u0026lt; 500; i += 10) { int x = int((i - b) / k); x = rng.uniform(x - 10, x + 10); int y = i; y = rng.uniform(y - 30, y + 30); cv::Point2f point(x, y); points.emplace_back(point); } //加入噪声 for (int i = 0; i \u0026lt; 800; i += 20) { int x = rng.uniform(1, 600); int y = rng.uniform(1, 800); cv::Point2f point(x, y); points.emplace_back(point); } } int main() { cv::Mat image(600, 800, CV_8UC3, cv::Scalar(125, 125, 125)); cv::Vec4f lineParam; std::vector\u0026lt;cv::Point2f\u0026gt; points; generateRandPointSet(600, 800, points); fitLineUseRANSAC(points, lineParam, 1000, 10); double k = lineParam[1] / lineParam[0]; double b = lineParam[3] - k * lineParam[2]; cv::Point p1, p2; p1.y = 600; p1.x = (p1.y - b) / k; p2.y = 0; p2.x = (p2.y - b) / k; cv::line(image, p1, p2, cv::Scalar(0, 255, 0), 2); int n = points.size(); for (int j = 0; j \u0026lt; n; ++j) { cv::circle(image, points[j], 5, cv::Scalar(0, 0, 0), -1); } cv::imshow(\u0026#34;image\u0026#34;, image); cv::waitKey(0); return 0; } 参考： RANSAC算法(附RANSAC直线拟合C++与Python版本)\n","permalink":"https://yyf.zone/notes/2021-3-11-ransac/","summary":"\u003cp\u003e图像匹配/经典算法/RANSAC算法\u003c/p\u003e","title":"RANSAC算法"},{"content":"计算机网络/物理层/宽带接入技术\n用户要连接到互联网，必须先连接到某个ISP，以便获得上网所需的IP地址。\nADSL技术 非对称数字用户线ADSL(Asymmetric Digital Subscriber Line)技术是用数字技术对现有的模拟电话用户线进行改造，使他能够承载宽带数字业务。\nADSL最大的好处就是可以利用现有电话线的用户线（铜线），而不需要重新布线。 ADSL借助于在用户线两端安装ADSL调制解调器对数字信号进行了调制，使得调制后的数字信号的频谱适合在原来的用户线上传输。 光纤同轴混合网（HFC网） 光纤同轴混合网(Hybrid Fiber Coax)是目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电话、数据和其他宽带交互型业务。\n为了提高传输的可靠性和电视信号的质量，HFC网把原有线电视网中的同轴电缆主干部分改换为光纤。 要使现有的模拟电视机恩能够接收数字电视信号，需要把一个机顶盒(set-top box)的设备连接在同轴电缆和用户电视机之间。 为了使用户能够利用HFC网接入到互联网，以及在上行信道中传送交互数字电视所需的一些信息，我们还需要增加一个为HFC网使用的调制解调器，它又称为电缆调制解调器(cable modem)。可以做成内置式的，安装在电视机的机顶盒里面。 FTTx技术 光纤到户FTTH(Fiber To The Home)就是把光纤一直铺设到用户家庭。只有在光纤进入用户家门后，才把光信号转换为电信号。这样做就可以使用户获得最高的上网速率。\nFTTx表示Fiber To The\u0026hellip;。这里字母x可代表不同的光纤接入地点。 一个家庭用户远远用不了一根光纤的通信容量。为了有效地利用光纤资源，在光纤干线和广大用户之间，还需要铺设一段中间的转换装置即光配网ODN(Optical Distribution Network)，使得数十个家庭用户能够共享一根光纤干线。无源的光配网常称为无源光网络PON(Passive Optical Network) 光配网由光线路终端OLT(Optical Line Terminal)、光分路器(splitter)、光网络单元ONU(Optical Network Unit)组成。光线路终端是连接到光纤干线的终端设备。OLT把收到的下行数据发往无源的1:N光分路器，然后用广播方式向所有用户端的光网络单元ONU发送。每一个ONU根据特有的标识值接收发送给自己的数据，然后转换为电信号发往用户家中。当发送上行数据时则是相反的过程。 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-2-1-fttx/","summary":"\u003cp\u003e计算机网络/物理层/宽带接入技术\u003c/p\u003e","title":"宽带接入技术"},{"content":"计算机网络/物理层/数字传输系统\n早期电话网：\n从市话局到用户电话机的用户线采用最廉价的双绞线电缆。 长途干线采用的是频分复用FDM的模拟传输方式。 现代电信网：\n长途干线大都采用时分复用PCM的数字传输方式。 光纤开始成为长途干线最主要的传输媒体。 早期数字传输系统存在的缺点： 速率标准不统一。由于历史原因，多路复用的速率体系有两个互不兼容的国际标准，北美和日本的T1速率和欧洲的E1速率。 不是同步传输。在过去相当长的时间，为了节约经费，各国的数字网主要采用准同步方式。在准同步系统中由于各支路信号的始终频率有一定的偏差，给时分复用和分用带来许多麻烦。 为了解决上述问题，美国在1988年首先推出了一个数字传输标准，叫做同步光纤网SONET(Synchronous Optical Network)。整个的同步网络的各级始终都来自一个非常精确的主时钟（通常是昂贵的铯原子钟）。SONET为光纤传输系统定义了同步传输的线路速率等级结构。 ITU-T以美国标准SONET为基础，制定出国际标准同步数字系统SDH(Synchronous Digital Hierarchy)。一般认为SDH和SONET是同义词，但其主要不同点是：SDH的基本速率为155.52Mbit/s，称为第1级同步传输模块(Synchronous Transfer Moudle)，即STM-1，相当于SONET体系中OC-3速率。\nSDH/SONET定义了标准光信号，规定了波长为1310nm和1550nm的激光源。 在物理层定义了帧结构。 第一次真正实现了数字传输体制上的世界性标准。 SDH标准也适合于微波和卫星传输的技术体制。 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-2-1-digitaltransmission/","summary":"\u003cp\u003e计算机网络/物理层/数字传输系统\u003c/p\u003e","title":"数字传输系统"},{"content":"计算机网络/物理层/信道复用技术\n频分复用、时分复用和统计时分复用 频分复用FDM(Frequency Division Multiplexing)最简单，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。可见频分复用的所有用户在同样的时间占用不同的带宽资源（这里的“带宽”是频率带宽而不是数据的发送速率）。\n时分复用TDM(Time Division Multiplexing)则是将时间划分为一段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中用固定序号的时隙。每一个用户所占用的时隙周期性的出现（其周期就是TDM帧的长度）。可见，时分复用的所有用户是在不同的时间占用同样的频带宽度。这两种复用方法的优点是技术比较成熟，但缺点是不够灵活，信道利用率不高。\n统计时分复用STDM(Statistic TDM)是一种改进的时分复用，它能明显地提高信道的利用率。集中器(concentrator)常使用这种统计时分复用。统计时分复用使用STDM帧来传送复用的数据。但每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中。对没有数据的缓存就跳过去。当一个帧的数据满了就发送出去。因此，STDM帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。统计时分复用有称为异步时分复用，而普通的时分复用称为同步时分复用。\n波分复用 波分复用WDM(Wavelength Division Multiplexing)就是光的频分复用，即使用一根光纤来同时传输多个频率很接近的光载波信号。\n码分复用 码分复用CDM(Code Division Multiplexing)即码分多址CDMA(Code Division Multiple Access)。由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-2-1-channelmultiplex/","summary":"\u003cp\u003e计算机网络/物理层/信道复用技术\u003c/p\u003e","title":"信道复用技术"},{"content":"计算机网络/物理层/物理层下面的传输媒体\n传输媒体就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类：\n导引型传输媒体 非导引型传输媒体 导引型传输媒体 双绞线。把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合起来就构成了双绞线。为了提高双绞线抗电磁干扰的能力，可以在双绞线的外面再加上一层用金属丝编织成的屏蔽层。这就是屏蔽双绞线。 同轴电缆。同轴电缆由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及保护塑料外层所组成。主要用在有线电视网的居民小区中。 光缆。光纤通信就是利用光导纤维（光纤）传递光脉冲来进行通信。光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。光纤通常由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通信圆柱体。一根光缆少则只有一根光纤，多则可包括数十至数百根光纤。光纤不仅具有通信容量非常大的优点，而且还具有其他的一些特点： 传输损耗小，中继距离长，对远距离传输特别经济。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好，也不易被窃听或窃取数据。 体积小，重量轻。 非引导型传输媒体 利用无线电波在自由空间的传播就可较快地实现多种通信。无线传输可使用的频段很广。紫外线和更高的波段目前还不能用于通信。\n低频 中频(300kHz~3MHz) 高频(3MHz~30MHz) 甚高频(30MHz~300MHz) 特高频(300MHz~3GHz) 超高频(3GHz~30GHz) 极高频(30GHz~300GHz) 短波通信（即高频通信）主要是靠电离层的反射。但电离层的不稳定所产生的衰落现象和电离层反射所产生的多径效应，使得短波信道的通信质量较差。因此，当必须使用短波无线电台传送数据时，一般都是低速传输。\n无线电微波通信在数据通信中占有重要地位。微波的频率范围为300Mhz~300GHz（波长１m~1mm），但主要使用２~40GHz的频率范围。微波在空间主要是直线传播。由于微波会穿透电离层而进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。传统的微波通信主要有两种方式，即地面微波接力通信和卫星通信。\n红外通信、激光通信也使用非导引型媒体。可用于近距离的笔记本电脑相互传送数据。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-31-transmissionmedium/","summary":"\u003cp\u003e计算机网络/物理层/物理层下面的传输媒体\u003c/p\u003e","title":"物理层下面的传输媒体"},{"content":"计算机网络/物理层/物理层的基本概念及涉及的基础知识\n物理层的基本概念 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\n物理层的主要任务\n可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：\n机械特性。指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。 电气特性。指明在接口电缆的各条线上出现的电压的范围。 功能特性。指明某条线上出现某一电平的电压的意义。 过程特性。指明对于不同功能的各种可能事件的出现顺序。 物理层还要完成传输方式的转换：并行转串行。\n数据通信的基础知识 数据通信系统模型 一个数据通信系统可以划分为三大部分，即源系统、传输系统和目的系统。\n信号可以分为两大类：\n模拟信号 数字信号 有关信道的几个基本概念 从通信的双方信息交互方式来看，可以有以下三种基本方式：\n单向通信，又称单工通信，即只能有一个方向的通信而没有反方向的交互。 双向交替通信，又称半双工通信，即通信的双方都可以发送消息，但不能双方同时发送。 双向同时通信，又称全双工通信，即通信的双方可以同时发送和接收信息。 编码与调制 来自信源的信号常称为基带信号（即基本频带信号）。基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行调制(modulation)。\n基带调制（编码）。仅仅对基带信号的波形进行变换，使它能够与信道特性向适应。变换后的信号仍然是基带信号。常用编码方式有： 不归零制。正电平代表１，负电平代表０。 归零制。正脉冲代表１，负脉冲代表０。 曼彻斯特编码。位周期中心的向上跳变代表０，位周期中心的向下跳变代表１。但也可反过来定义。 差分曼彻斯特编码。在每一位的中心处始终都有跳变。位开始边界有跳变代表０，而位开始边界没有跳变代表１。 带通调制。使用载波(carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号。基本的带通调制方法有： 调幅(AM)，即载波的振幅随基带数字信号而变化。 调频(FM)，即载波的频率随基带数字信号而变化。 调相(PM)，即载波的初始相位随基带数字信号而变化。 为了达到更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法。例如，正交振幅调制QAM(Quadrature Amplitude Modulation)。 信道的极限容量 从概念上讲，限制码元在信道上的传输速率的因素有以下两个：\n信道能够通过的频率范围 码间串扰。如果信号中的高频分量在传输时受到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，每一个码元所占的时间界限也不再是很明确的，而是前后都拖了“尾巴”。 奈氏准则表明，在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。 如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。 信噪比 信噪比就是信号的平均功率和噪声的平均功率之比，常记为$S/N$，并用分贝(dB)作为度量单位。 $$ 信噪比(dB)=10lg(S/N) $$ 香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。\n$$C=Wlog_{2}(1+S/N)(bit/s)$$ 式中，C为信道的极限信息传输速率；W为信道的带宽（以Hz为单位）；S为信道内所传信号的平均功率；N为信道内部的高斯噪声功率。 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-31-physicallayer/","summary":"\u003cp\u003e计算机网络/物理层/物理层的基本概念及涉及的基础知识\u003c/p\u003e","title":"物理层的基本概念及涉及的基础知识"},{"content":"计算机网络/数据链路层/高速以太网\n100BASE-T以太网 100BASE-T是在双绞线上传送100Mbit/s基带信号的星形拓扑以太网，仍使用IEEE 802.3的CSMA/CD协议，它又称为快速以太网(Fast Ethernet)。\n用户只要使用100Mbit的适配器和100Mbit的集线器或交换机，即可以很方便地由10BASE-T以太网直接升级到100Mbit/s，而不需要改变网络拓扑。 100BASE-T可使用以太网交换机提供很好的服务质量，可在全双工方式下工作而无冲突发生。 IEEE 802.3u的标准为包括对同轴电缆的支持。这意味着想从细缆以太网升级到快速以太网的用户必须重新布线。因此，现在10/100Mbit/s以太网都使用无屏蔽双绞线布线。 参数a必须保持为很小的数值。所以网络电缆线的长度有极限。 吉比特以太网 吉比特以太网的标准IEEE 802.3z有以下几个特点：\n允许在1Gbit/s下以全双工和半双工两种方式工作。 使用IEEE 802.3协议规定的帧格式。 在半双工方式下使用CSMA/CD协议，而在全双工方式不使用CSMA/CD协议。 与10BASE-T和100BASE-T技术向后兼容。 吉比特以太网工作在半双工方式时，就必须进行碰撞检测。由于数据率提高了，因此只有减小最大电缆长度或增大帧的最小长度，才能使参数a保持为较小的数值。吉比特仍然保持一个网段的最大长度为100m，但采用了“载波延伸”(carrier extension)的办法，使最短帧长仍为64字节（这样可以保持兼容性），同时将争用期增大为512字节。吉比特以太网还增加了一种功能称为分组冲突(packet bursting)。就是当很多短帧要发送时，第一个短帧要采用上面所说的载波延伸的方法进行填充。但随后的一些短帧则可一个接一个地发送，他们之间只需留有必要的帧间最小间隔即可。当吉比特以太网工作在全双工方式时，不使用载波延伸和分组冲突。\n10吉比特以太网(10GE)和更快的以太网 10GE的帧格式与10Mbit/s，100Mbit/s和1Gbit/s以太网的帧格式完全相同，并保留了802.3标准规定的以太网最小帧长和最大帧长。 10GE只工作在全双工方式，因此不存在争用问题，当然也不使用CSMA/CD协议。这就使得10GE的传输距离大大提高了（因为不再受必须进行碰撞检测的限制）。 现在以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从而实现端到端的以太网传输。这种工作方式的好处是：\n以太网是一种经实践证明的成熟技术，无论是互联网服务提供者ISP还是端用户都很愿意使用以太网。当然对ISP来说，使用以太网还需要在更大的范围进行试验。 以太网的互操作性也很好，不同厂商生产的以太网都能可靠地进行互操作。 在广域网中使用以太网时，其价格大约只有同步光钎网SONET的五分之一和异步传递方式ATM的十分之一。以太网还能够适应多种传输媒体，如铜缆、双绞线以及各种光缆。这就使具有不同传输媒体的用户在进行通信时不必重新布线。 端到端的以太网连接使帧的格式全都是以太网的格式，而不需要再进行帧的格式转换，这就简化了操作和管理。 使用以太网进行宽带接入 使用以太网进行宽带接入的优点：\n可提供双向的宽带通信，并且可以根据用户对宽带的需求灵活地进行宽带升级。 当城域网和广域网都采用吉比特以太网或10吉比特以太网时，采用以太网接入可以实现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率且降低了传输的成本。 需要加入鉴别用户身份的功能：\n把数据链路层的两个成功的协议结合起来，即PPP协议中的PPP帧在封装到以太网中来传输。这就是PPPoE(PPP over Ethernet)，意思是“在以太网上运行PPP”。现在的光纤宽带接入FTTx都要使用PPPoE的方式进行接入。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-29-fastethernet/","summary":"\u003cp\u003e计算机网络/数据链路层/高速以太网\u003c/p\u003e","title":"高速以太网"},{"content":"计算机网络/数据链路层/扩展的以太网\n在物理层扩展以太网 扩展主机的集线器之间的距离的一种简单方法就是使用光纤和一对光纤调制解调器。光纤调制解调器的作用就是进行电信号和光信号的转换。由于光纤带来的时延很小，并且带宽很宽，因此使用这种方法可以很容易地使主机和几公里以外的集线器相连接。\n如果使用多个集线器，就可以连接成覆盖更大范围的多级星形结构的以太网。\n但这种多级结构的集线器以太网也带来了一些缺点：\n碰撞域增大。 不同以太网兼容成本大。 在数据链路层扩展以太网 以太网交换机的特点 交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口，和工作在物理层的转发器、集线器有很大的差别。以太网交换机的每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。以太网交换机还具有并行性，即能同时连通多对接口，使多对主机能同时通信。相互通信的主机都是独占传输媒体，无碰撞地传输数据。 以太网交换机的接口还有存储器，能在输出端口繁忙时把到来的帧进行缓存。 以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的。 以太网交换机的性能远远超过普通的集线器，而且价格并不贵，这就使工作在物理层的集线器逐渐地退出了市场。 虚拟局域网 虚拟局域网VLAN(Virtual LAN)是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个局域网。\n由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地组合，使用户从不同的服务器或数据库中存取所需的资源。\n虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为VLAN标记(tag)，用来指明发送该帧的计算机属于哪一个虚拟局域网。\n当数据链路层检测到MAC帧的源地址字段后面的两个字节的值是0x8100时，即知道现在插入了4字节的VLAN标记。于是就接着检查后面两个字节的内容。在后面的两个字节中，前3位是用户优先级字段，接着的一位是规范格式指示符CFI(Canonical Format Indicator)，最后的12位是该虚拟局域网VLAN标识符VID(VLAN ID)，它唯一地标志了这个以太网帧属于哪一个VLAN。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-29-extendedethernet/","summary":"\u003cp\u003e计算机网络/数据链路层/扩展的以太网\u003c/p\u003e","title":"扩展的以太网"},{"content":"计算机网络/数据链路层/使用广播信道的数据链路层\n局域网的数据链路层 局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。\n局域网具有如下一些主要优点：\n具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性(reliability)、可用性(availability)和生存性(survivability)。 网络适配器（网卡） 计算机与外界局域网的连接是通过通信适配器(adapter)进行的。适配器本来是主机箱内插入的一块网络接口板（或者是在笔记本电脑中插入一块PCMCIA卡\u0026ndash;个人计算机存储器卡适配器）。这种接口板又称为网络接口卡NIC(Network Interface Card)或简称为“网卡”。现在计算机主板上都已经嵌入了这种适配器，不再使用单独的网卡了。\n适配器和局域网之间的通信是通过电缆线或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的I/O总线以x传输方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。\n适配器在接收和发送各种帧时，不使用计算机的CPU。当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。\nCSMA/CD协议 总线的特点是：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据。总线上只要有一台计算机在发送数据，总线的传输资源就被占用。因此，在同一时间只能允许一台计算机发送数据，否则各计算机之间就会互相干扰。以太网的协调方法是CSMA/CD协议，意思是载波监听多点接入/碰撞检测(Carrier Sense Mutiple Access with Collision Detection)。\n为了通信的简便，以太网采取了一下两种措施：\n采用较为灵活的无连接的工作方式。适配器对发送的数据帧不进行编号，也不要求对方发回确认。以太网提供的服务是尽最大努力的交付，即不可靠的交付。当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。对有差错帧是否需要重传则由高层来确定。 以太网发送的数据都使用曼切斯特(Manchester)编码的信号。 CSMA/CD协议的要点：\n“多点接入”就是说明这是总线型网络，许多计算机以多点接入的方式接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。 “载波监听”就是用电子技术检测总线上有没有其他计算机也在发送。载波监听就是检测信道，这是个很重要的措施。不管在发送前，还是发送中，每个站都必须不停地检测信道。 “碰撞检测”也就是“边发送边监听“，即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。 CSMA/CD协议的主要内容：\n准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中。但在发送之前，必须先检测信道。\n检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在96比特时间内信道保持空闲（保证了帧间的最小距离），就发送这个帧。\n在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里有两种可能性：\n发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到(1)。 发送失败：在争用期内检测到碰撞。这是立即停止发送数据，并按规定发送认为干扰信号。适配器接着就执行指数退避算法，等待r倍512比特时间后，返回到步骤(2)，继续检测信道。但若重传达到16次仍不能成功，则停止重传而向上报错。 争用期：\n以太网的端到端往返时间$2\\tau$称为争用期。\n使用集线器的星形拓扑 集线器的一些特点：\n使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。 一个集线器有许多接口。 集线器工作在物理层。 集线器采用了专门的芯片，进行自适应串音回波抵消。 以太网的信道利用率 极限信道利用率：\n$$S_{max}=T_{0}/(T_{0}+\\tau)=1/(1+a)$$ 以太网中定义了参数a：\n$$a=\\tau/T_{0}$$\n以太网的MAC层 MAC层的硬件地址 在局域网中，硬件地址又称为物理地址或MAC地址。\n局域网规定了一种48位的全球地址（一般都简称为“地址”），是指局域网上的每一台计算机中固化在适配器的ROM中的地址。\nMAC帧的格式 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-29-broadcast/","summary":"\u003cp\u003e计算机网络/数据链路层/使用广播信道的数据链路层\u003c/p\u003e","title":"使用广播信道的数据链路层"},{"content":"计算机网络/数据链路层/使用点对点信道的数据链路层\n数据链路和帧 数据链路是物理链路加上必要的通信协议。\n帧是点对点信道的数据链路层的协议数据单元。\n数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。\n三个基本问题 三个基本问题是：封装成帧、透明传输和差错检测。\n封装成帧 封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。首部和尾部的一个重要作用就是帧定界（即确定帧的界限）。此外，首部和尾部还包括许多必要的控制信息。每一种链路层协议都规定了所能传送的帧的数据部分长度上限\u0026ndash;最大传送单元MTU(Maximum Tranfer Unit)。\n帧定界可以使用特殊的帧定界符。控制字符SOH(Start Of Header)放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT(End Of Transmission)表示帧的结束。\n透明传输 不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。为了解决透明传输问题，就必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。\n具体的方法是：发送端的数据链路层在数据中出现控制字符前面插入一个转义字符“ESC”。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为字节填充(byte stuffing)或字符填充(character stuffing)。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。\n差错检测 比特错误 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了循环冗余检验CRC(Cyclic Redundancy Check)的检错技术。\n循环冗余检验的原理\n对于k个比特的数据M，CRC运算就是在数据M的后面添加供差错检测用的n位冗余码，然后构成帧发送出去。 n位的冗余码可用以下方法得出。用二进制的模2运算进行$2^{n} \\times M$的运算，这相当于在M后面添加n个0。得到的$(k+n)$位的数除以收发双方事先商定的长度为$(n+1)$位的除数P，得出商是Q而余数是R（n位）。这个余数R就作为冗余码拼接在数据M的后面发送出去。这种为了进行检错而添加的冗余码常称为帧检验序列FCS(Frame Check Sequence)。 在接收端把接收到的数据以帧为单位进行CRC检验：把收到的每一个帧都除以同样的除数P（模2运算），然后检查得到的余数R。 $$R=0$$，无差错，接受(accept)。\n$$R\\neq0$$，有差错，丢弃\n帧丢失、帧重复、帧失序 在CRC检错的基础上，增加了帧编号、确认和重传机制。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-25-datalinklayer/","summary":"\u003cp\u003e计算机网络/数据链路层/使用点对点信道的数据链路层\u003c/p\u003e","title":"使用点对点信道的数据链路层"},{"content":"计算机网络/数据链路层/点对点协议PPP\nPPP协议的特点 简单。IETF在设计互联网体系结构时把其中最复杂的部分放在TCP协议中，而网际协议IP则相对比较简单，它提供的是不可靠的数据服务。在这种情况下，数据链路层没有必要提供比IP协议更多的功能。因此，对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。 封装成帧。PPP协议必须规定特殊的字符作为帧定界符。 透明性。PPP协议必须保证数据传输的透明性。 多种网络层协议。PPP协议必须能够在同一条物理链路上同时支持多种网络层协议的运行。 多种类型链路。PPP协议必须能够在多种类型的链路上运行。 差错检测(error detection)。PPP协议必须能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。 检测连接状态。PPP协议必须具有一种机制能够及时（不超过几分钟）自动检测出链路是否处于正常工作状态。 最大传送单元。PPP协议必须对每一个种类型的点对点链路设置最大传送单元的标准默认值。 网络层地址协商。PPP协议必须提供一种机制使通信的两个网络层（例如，两个IP层）的实体能够通过协商知道或能够配置彼此的网络层地址。 数据压缩协商。ppp协议必须提供一种方法来协商数据压缩算法。 PPP协议有三个组成部分：\n一个将IP数据报封装到串行链路的方法。 一个用来建立、配置和测试数据链路连接的链路控制协议LCP(Link Control Protocol)。 一套网络控制协议NCP(Network Control Protocol)，其中的每一个协议支持不同的网络层协议。 PPP协议的帧格式 各字段的意义 PPP帧的首部和尾部分别为四个字段和两个字段。\n首部的第一个字段和尾部的第二个字段都是标志字段F(Flag)，规定为0x7E。标志字段表示一个帧的开始或结束（定界符）。 首部中的地址字段A规定为0xFF，控制字段C规定为0x03。最初曾考虑以后再对这两个字段的值进行其他定义，但至今也没有给出。可见这两个字段实际上并没有携带PPP帧的信息。 首部的第四个字段是2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。若为0xC021，则信息字段是PPP链路控制协议LCP的数据，而0x8021表示这是网络层的控制数据。 信息字段的长度是可变的，不超过1500字节。 尾部中的第一个字段（2字节）是使用CRC的帧检验序列FCS。 透明传输的实现 字节填充 当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。\n当PPP使用异步传输时，它把转义字符定义为0x7D，并使用字节填充。\n把信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D,0x5E)。 如信息字段中出现一个0x7D的字节（即出现了和转义字符一样的比特组合），则把0x7D转变成为2字节序列(0x7D,0x5D)。 若信息字段中出现ASCII码的控制字符（即数值小于0x20的字符），则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。 零比特填充 PPP协议用在SONET/SDH链路时，使用同步传输（一连串的比特连续传送）而不是异步传输（逐个字符地传送）。在这种情况下，PPP协议采用零比特填充的方法来实现透明传输。\n零比特填充的具体做法是：在发送端，先扫描整个信息字段。只要发现有5个连续1，则立即填入一个0。因此经过这种零比特填充后的数据，就可以保证在信息字段中不会出现6个连续的1。\nPPP协议的工作状态 当用户拨号接入ISP后，就建立了一条从用户个人电脑到ISP的物理连接。这时，用户个人电脑向ISP发送一系列的链路控制协议LCP分组（封装成多个PPP帧），以便建立LCP连接。这些分组及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一个临时的IP地址。这样，用户个人电脑就成为互联网上的一个有IP地址的主机了。\n当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-25-ppp/","summary":"\u003cp\u003e计算机网络/数据链路层/点对点协议PPP\u003c/p\u003e","title":"点对点协议PPP"},{"content":"计算机网络/应用层/文件传送协议FTP\n文件共享协议：\n复制整个文件的：FTP，TFTP 联机访问：NFS FTP FTP使用客户服务器方式。一个FTP服务器进程可同时为多个客户提供服务。FTP的服务进程有两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。\n图中椭圆表示在系统中运行的进程。图中服务器端有两个从属进程：控制进程和数据传送进程。\n在进行文件传输时，FTP的客户和服务器之间要建立两个并行的TCP连接：“控制连接”和“数据连接”。FTP客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际传输文件的是“数据连接”。服务器端的控制进程在接收到FTP客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。\nNFS FTP并非对所有的数据传输都是最佳的。例如，要在远地计算机的一个很大的文件末尾添加一行信息。若使用FTP则要先把文件传送过来，添加信息后在传送过去。网络文件系统NFS则采用另一种思路。NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上好事读写数据。对于上述例子，NFS客户把要添加的数据和在文件后面写数据的请求一起发送到远地计算机，NFS服务器更新文件后返回应答信息。\nTFTP 简单文件传送协议TFTP也使用客户服务器方式，但它使用UDP数据报。因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。TFTP的工作很像停止等待协议。\n优点：\n可用于UDP环境 TFTP代码所占的内存小。这对较小的计算机或某些特殊用途的设备很重要。 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-22-ftp/","summary":"\u003cp\u003e计算机网络/应用层/文件传送协议FTP\u003c/p\u003e","title":"文件传送协议FTP"},{"content":"计算机网络/应用层/远程终端协议TELNET\nTELNET是一个简单的远程终端协议，用户用TELNET就可在其所在地通过TCP连接注册（即登录）到远地的另一台主机上（使用主机名或IP地址）。TELNET能将用户的击键传到远地主机，同时也能将远地主机上的输出通过TCP连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。\nTELNET的特点：\nTELNET也使用客户服务器方式。和FTP的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。 TELNET能够适应许多计算机和操作系统的差异。例如许多系统的功能按键都不一样，指令也不一样。为了适应这种差异，TELNET定义了数据和命令应怎样通过互联网。这写定义就是所谓的网络虚拟终端NVT(Network Virtual Terminal) 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-22-telnet/","summary":"\u003cp\u003e计算机网络/应用层/远程终端协议TELNET\u003c/p\u003e","title":"远程终端协议TELNET"},{"content":"计算机网络/网络层/网际协议IP\n与IP协议配套使用的还有三个协议：\n地址解析协议ARP(Address Resolution Protocol) 网际控制报文协议ICMP(Internet Control Message Protocol) 网际组管理协议IGMP(Internet Group Management Protocol) 分类的IP地址 IP地址及其表示方法 IP地址的编址方法共经过三个历史阶段。\n分类的IP地址。这是最基本的编址方法。 子网的划分。这是对最基本的编址方法的改进。 构成超网。这是比较新的无分类编址方法。 IP地址::={\u0026lt;网络号\u0026gt;,\u0026lt;主机号\u0026gt;}\n常见的IP地址 IP地址具有以下一些重要特点。\n每一个IP地址都由网络号和主机号两部分组成。 实际上IP地址是标志一台主机（或路由器）和一条链路的接口。 按照互联网的观点，一个网络是指具有相同网络号net-id的主机集合。 在IP地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是平等的。 IP地址与硬件地址 从层次的角度看，物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址（称IP地址为逻辑地址是因为IP地址是用软件实现的）。\n在IP层抽象的互联网上只能看到IP数据报。 虽然在IP数据报首部有源站IP地址，但路由器只根据目的站的IP地址的网络号进行路由选择。 在局域网的链路层，只能看见MAC帧。 尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了下层这些很复杂的细节。 地址解析协议ARP ARP协议的用途是为了从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。\n每一台主机都设有一个ARP高速缓存(ARP cache)，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，并且这个映射表还经常动态更新。\n映射表的更新通过广播ARP请求分组和单播ARP响应分组来完成。ARP对保存在高速缓存中的每一个映射地址项目都设置生存时间。凡超过生存时间的项目就从高速缓存中删除。\nARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。\nIP数据报的格式 IP数据报首部的固定部分中的各字段 版本 占4位，指IP协议的版本。\n首部长度 占4位，可表示的最大十进制数值是15。\n区分服务 占8位，用来获得更好的服务。未使用\n总长度 占16位，总长度指首部和数据之和的长度，单位为字节。\n标识(identification) 占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。\n标志(flag) 占3位，但目前只有两位有意义。\nMF(More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。 DF(Don\u0026rsquo;t Fragment)。意思是“不能分片”。只有当DF=0时才允许分片。 片偏移 占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。\n生存时间 占8位，生存时间字段常用的英文缩写是TTL(Time To Live)，表明这是数据报在网络中的寿命，即跳数限制。\n协议 占8位，协议字段指出此数据报携带的数据是使用何种协议。\n首部检验和 占16位。这个字段只检验数据报的首部，但不包括数据部分。\n源地址 占32位。\n目的地址 占32位。\n可变部分。IP数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施。此字段的长度可变，从1个字节到40个字节不等，取决于所选择的项目。\nIP层转发分组的流程 分组转发算法如下：\n从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N。 若N就是此路由器直接相连的某个网络，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址D转换为具体硬件地址，把数据报封装为MAC帧，再发送此帧）；否则就是间接交付，执行(3) 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。 若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(5)。 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则执行(6)。 报告转发分组出错。 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-22-ip/","summary":"\u003cp\u003e计算机网络/网络层/网际协议IP\u003c/p\u003e","title":"网际协议IP"},{"content":"计算机网络/网络层/划分子网和构造超网\n划分子网 从二级地址到三级地址 一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网(subnet)。 划分子网的方法是从网络的主机号借用若干位作为子网号(subnet-id)，当然主机号也就相应减少同样的位数。 IP地址::={\u0026lt;网络号\u0026gt;,\u0026lt;子网号\u0026gt;,\u0026lt;主机号\u0026gt;}\n凡是从其他网络发送给本单位某台主机的IP数据报，仍然是根据IP数据报的目的网络号找到连接在本单位网络上的路由器。 子网掩码 子网掩码中的1对应于IP地址中原来二级地址中16位网络号加上新增的子网号，而子网掩码中的0对应于现在的主机号。\n使用子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的“与”运算(AND)，就立即得到网络地址来。\n现在互联网规定，所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中的1的位置和IP地址中的网络号字段net-id正好相对应。\n划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。\n使用子网时分组的转发 使用子网划分后，路由表必须包含一下三项内容：目的网络地址、子网掩码和下一跳地址。\n无分类编址CIDR（构造超网） 网络前缀 无分类域间路由选择CIDR(Classless Inter-Domain Routing)的特点：\nCIDR消除了传统的A类、B类和C类地址以及划分子网的概念，因而能更加有效地分配IPv4的地址空间，并且在新的IPv6使用之前容许互联网的规模继续增长。CIDR把32位的IP地址划分为前后两个部分。前面部分是“网络前缀”(network-prefix)，用来指明网络，后面部分则用来指明主机。CIDR还可以用斜线记法，即在IP地址后面加上斜线“/”，然后写上网络前缀所占的位数。 IP地址::={\u0026lt;网络前缀\u0026gt;,\u0026lt;主机号\u0026gt;}\nCIDR把网络前缀都相同的连续的IP地址组成一个“CIDR地址块”。我们只知道CIDR地址块中任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。\n由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。这种地址的聚合常称为路由聚合(route aggregation)。路由聚合也称为构成超网(supernetting)。路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 最长前缀匹配 在使用CIDR时，路由表中的项目也要有相应的改变。这时，每个项目由“网络前缀”和“下一跳地址”组成。但是在查找路由表时可能会得到不止一个匹配结果。应当从匹配结果中选择具有最长网络前缀的路由。这叫做最长前缀匹配(longest-prefix matching)\n使用二叉线索查找路由表 使用CIDR后，由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。对于无分类编址的路由表的最简单的查找算法就是对所有可能的前缀进行循环查找。所找到的最长匹配就对应于要查找的路由。这种最简单的算法的明显缺点就是查找的次数太多。\n为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索(binary trie)，它是一种特殊结构的树。IP地中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-21-cidr/","summary":"\u003cp\u003e计算机网络/网络层/划分子网和构造超网\u003c/p\u003e","title":"划分子网和构造超网"},{"content":"计算机网络/网络层/网际控制报文协议ICMP\n为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol)。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP是IP层的协议。ICMP报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出去。\nICMP报文 ICMP报文种类 ICMP报文的种类有两种，即ICMP差错报文和ICMP询问报文。\nICMP差错报文共有四种：\n终点不可达。当路由器或主机不能交付数据报时就向源点发送终点不可达报文。 时间超过。当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片丢弃，并向源点发送时间超过报文。 参数问题。当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。 改变路由（重定向）。路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。 常用的ICMP询问报文有两种：\n回送请求和回答。ICMP回送请求报文是由报文或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。 时间戳请求和回答。ICMP时间戳请求报文是请某台主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。 ICMP应用举例 分组网间探测PING ICMP的一个重要应用就是分组网间探测PING(Packet InterNet Groper)，用来测试两台主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。PING是应用层直接使用网络层ICMP的一个例子。它没有通过运输层的TCP或UDP。\ntraceroute 另一个非常有用的应用是traceroute（这是UNIX操作系统中的名字），它用来跟踪一个分组从源点到终点的路径。在Windows操作系统中这个命令是tracert。\nTraceroute从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的UDP用户数据报。第一个数据报P1的生存时间TTL设置为1.当P1到达路径上的第一个路由器R1时，R1先收下它，接着把TLL减1.由于TTL等于零了，R1就把P1丢弃了，并向源主机发送一个ICMP时间超过差错报告报文。\n源主机接着发送第二个数据报P2，并把TTL设置成2。这样一直继续下去。当最后一个数据报刚刚到达目的主机时，数据报的TTL是1。主机不转发数据报，也不把TTL值减1。但因IP数据报中封装的是无法交付的运输层的UDP用户数据报，因此目的主机要向源主机发送ICMP终点不可达差错报告报文。\n这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的ICMP报文正好给出了源主机想知道的路由信息————到达目的主机所经过的路由器的IP地址。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-21-icmp/","summary":"\u003cp\u003e计算机网络/网络层/网际控制报文协议ICMP\u003c/p\u003e","title":"网际控制报文协议ICMP"},{"content":"计算机网络/网络层/互联网的路由选择协议\n路由选择协议的几个基本概念 理想的路由算法 算法必须是正确的和完整的。 算法在计算上应简单。 算法应能适应通信量和网络拓扑的变化。 算法应具有稳定性。 算法应是公平的。 算法应是最佳的。 分层次的路由选择协议 互联网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。为此，可以把整个互联网划分为许多较小的自治系统(autonomous system)，一般都记为AS。自治系统AS是单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。\n在目前的互联网中，一个大的ISP就是一个自治系统。这样，互联网就把路由选择协议划分为两大类。\n1. 内部网关协议IGP(Interior Gateway Protocol)。即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如RIP和OSPF协议。\n2. 外部网关协议EGP(External Gateway Protocol)。若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。目前使用最多的外部网关协议是BGP协议。\n内部网关协议RIP RIP(Routing Information Protocol)是一种分布式的基于距离向量的路由选择协议，其最大优点就是简单。\nRIP协议的“距离”也称为“跳数”(hop count)，每经过一个路由器，跳数就加1。RIP认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP允许一条路径最多只能包含15个路由器。可见RIP只适用于小型互联网。\nRIP协议的特点：\n仅和相邻路由器交换信息。 路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。 按固定的时间间隔交换路由信息。 路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳地址。路由表更新的原则是找到每个目的网络的最短距离。这种更新算法又称为距离向量算法。\n内部网关协议OSPF 开放最短路径优先OSPF(Open Shortest Path First)最主要的特征就是使用分布式的链路状态协议(link state protocol)，而不是像RIP那样的距离向量协议。和RIP协议相比，OSPF的三个要点和RIP的都不一样：\n向本自治系统中所有路由器发送信息。 发送的信息就是本路由器相邻的所有路由器的链路状态。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。OSPF将这个“度量”用来表示费用、距离、时延、带宽等等。 只有当链路发生变化时，路由器才向所有路由器用洪泛法发送此信息。 所有的路由器最终都能建立一个链路状态数据库(link-state database)，这个数据库实际上就是全网的拓扑结构图。\n外部网关协议BGP 由于1）互联网的规模太大，使得自治系统AS之间路由选择非常困难。2）自治系统AS之间的路由选择必须考虑有关策略。边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。BGP采用了路径向量(path vector)路由选择协议，它与距离向量协议（如RIP）和链路状态协议（如OSPF）都有很大的区别。\nBGP发言人\n在配置BGP时，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”。BGP发言人往往就是BGP边界路由器，但也可以不是。\n邻站(neighbor)或对等站(peer)\n使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站或对等站。\n边界网关协议BGP所交换的网络可达性的信息就是要到达某个网络（用网络前缀表示）所要经过的一系列自治系统。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。\n路由器的构成 整个路由器结构可划分为两大部分：路由选择部分和分组转发部分。\n路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的路由选择构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。\n分组转发部分由三部分组成：交换结构、一组输入端口和一组输出端口。交换结构(switching fabric)又称交换组织，它的作用就是根据转发表(forwarding table)对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-19-route/","summary":"\u003cp\u003e计算机网络/网络层/互联网的路由选择协议\u003c/p\u003e","title":"互联网的路由选择协议"},{"content":"计算机网络/应用层/P2P应用\nP2P应用就是指具有P2P体系结构的网络应用。所谓P2P体系结构就是在这样的网络应用中，没有（或只有极少数的）固定的服务器，而绝大多数的交互都是使用对等方式（P2P方式）进行的。\n具有集中目录服务器的P2P工作方式（第一代） 最早使用P2P工作方式的是Napster。Napster能够搜索音乐文件，能够提供检索功能。所有音乐文件的索引信息都集中存放在Napster目录服务器中。这个目录起着索引的作用。\nNapster的文件传输是分散的（P2P方式），但文件的定位则是集中的（客户-服务器方式）。\n具有全分布式结构的P2P文件共享程序（第二代、第三代） Gnutella（第二代）是一种采用全分布方式定位内容的P2P文件共享应用程序。Gnutella与Napster最大的区别就是不使用集中式的目录服务器进行查询，而是使用洪泛法在大量Gnutella用户之间进行查询。为了不使查询的通信量过大，Gnutella设计了一种有限范围的洪泛查询。\n第三代P2P共享文件程序使用分散定位和分散传输技术。如比特洪流BT(Bit Torrent)等。\nBitTorrent把参与某个文件分发的所有对等方的集合称为一个洪流(torrent)。把对等方下载文件的数据单元称为文件块(chunk)，一个文件块的长度是固定不变的，例如，典型的数值是256KB。每一个洪流都有一个基础设施结点，叫做追踪器(tracker)。当一个对等方加入洪流时，必须向追踪器登记，并周期性地通知追踪器它仍在洪流中。\n在任何时刻，每一个对等方可能只拥有某文件的一个文件块子集，而不同的对等方所拥有的文件块子集也不会完全相同。对等方A将通过TCP连接周期性地向相邻对等方索取他们拥有的文件块列表。根据收到的文件列表，A就知道了应当请求哪一个相邻对等方把哪些子集缺少的文件块发送过来。\n然后A必须做出两个重要决定。第一，哪些文件块是首先需要向其他相邻对等方请求的？第二，在很多向A请求文件块的相邻对等方中，A应当向哪些相邻对等方发送所请求的文件块？ 对于第一个问题，A要使用叫做最稀有的优先的技术。A首先应当请求副本最少的文件块（即最稀有的）。否则，一旦拥有最稀有的文件块的对等方退出了洪流，就会影响A对所缺失文件块的收集。\n对于第二个问题，BT采用一种更加机灵的算法，其基本思想是：凡是以最高数据率向A传送文件块的某相邻对等方，A就优先把所请求的文件块送给该相邻对等方。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-19-p2p/","summary":"\u003cp\u003e计算机网络/应用层/P2P应用\u003c/p\u003e","title":"P2P应用"},{"content":"计算机网络/应用层/应用进程跨越网络的通信\n系统调用和应用编程接口 大多数操作系统使用系统调用(system call)的机制在应用程序和操作系统之间传递控制权。应用进程需要从操作系统获得服务，就要把控制权传递给操作系统，操作系统在执行必要的操作后把控制权返回给应用进程。因此，系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口。由于应用程序在使用系统调用之前要编写一些程序，特别是需要设置系统调用的许多参数，因此这种系统调用接口又称为应用编程接口API(Application Programming Interface)。\n在讨论网络编程时常常把套接字作为应用进程和运输层协议之间的接口。当应用进程（客户或服务器）需要使用网络进行通信时，必须首先发出socket系统调用，请求操作系统为其创建一个“套接字”。这个调用的实际效果是请求操作系统把网络通信所需要的一些系统资源（存储空间、CPU时间、网络带宽等）分配给应用进程。操作系统作为这些资源的总和用一个叫做套接字描述符(socket descriptor)的号码（小的整数）来表示，然后把这个套接字描述符返回给应用进程。几乎所有的网络系统调用都把这个套接字描述符作为套接字的许多参数中的第一个参数。通信完毕后，应用进程通过一个关闭套接字的close系统调用通知操作系统回收与该套接字描述符相关的所有资源。由此可见，套接字是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制。\n常用的系统调用 以TCP的服务为例\n连接建立阶段\n当套接字被创建后，它的端口号和IP地址都是空的，因此应用进程要调用bind（绑定）来指明套接字的本地地址（本地端口号和本地IP地址）。在服务器端调用bind时就是把熟知端口和本地IP地址填写到已创建的套接字中。这就叫做把本地地址绑定到套接字。在客户端也可以不调用bind，这时由操作系统内核自动分配一个动态端口号（通信结束后由系统收回）。\n服务器在调用bind后，还必须调用listen（监听）把套接字设置为被动方式，以便随时接收客户的服务请求。UDP服务器由于只提供无连接服务，不使用listen系统调用。\n服务器紧接着就调用accept（接受），以便把远地客户进程发来的连接请求提取出来。系统调用accept的一个变量就是要指明是从哪一个套接字发起的连接。\n调用accept要完成的动作较多。这是因为一个服务器必须能够同时处理多个连接。这样的服务器常称为并发方式(concurrent)工作的服务器。\n当使用TCP协议的客户已经调用socket创建了套接字后，客户进程就调用connect，以便和远地服务器建立连接。在connect系统调用中，客户必须指明远地端点（即远地服务器的IP地址和端口号）。 数据传送阶段\n客户和服务器都在TCP连接上使用send系统调用传送数据，使用recv系统调用接收数据。\n调用send需要三个变量：数据要发往的套接字的描述符、要发送的数据的地址以及数据的长度。\n调用recv也需要三个变量：要使用的套接字的描述符、缓存的地址以及缓存空间的长度。 连接释放阶段\n调用close释放连接和撤销套接字。 UDP服务器由于只提供无连接服务，因此不使用listen和accept系统调用。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-18-socket/","summary":"\u003cp\u003e计算机网络/应用层/应用进程跨越网络的通信\u003c/p\u003e","title":"应用进程跨越网络的通信"},{"content":"计算机网络/应用层/简单网络管理协议SNMP\n网络管理的基本概念 网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能、服务质量等。\n网络管理模型中的主要构件\n管理站。\n管理站又称为管理器，是整个网络管理系统的核心，它通常是个有着良好图形界面高性能的工作站，并由网络管理员直接操作和控制。管理站的所在部门也常称为网络运行中心NOC(Network Operations Center)。管理站中的关键构件是管理程序。管理程序在运行时就成为管理进程。管理站（硬件）或管理程序（软件）都可称为管理者(Manager)或管理器。 被管设备。\n在被管网络中有很多的被管设备（包括设备中的软件）。被管设备可以是主机、路由器、打印机、集线器、网桥或调制解调器等。在每一个被管设备中可能有许多被管对象(Managed Object)。被管设备有时可称为网络元素或简称为网元。 网络管理协议。\n简单网络管理协议SNMP(Simple Network Management Protocol)中的管理程序和代理程序按客户服务器方式工作。管理程序运行SNMP客户程序，而代理程序运行SNMP服务器程序。 网络管理的基本原则\n若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有对象的影响必须尽量小些。 SNMP最重要的指导思想就是要尽可能简单。SNMP的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。 SNMP的网络管理由三个部分组成\nSNMP本身。SNMP定义了管理站和代理之间所交换的分组格式。 管理信息结构SMI(Structure of Management Information)。SMI定义了命名对象和定义 对象类型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的规则。 管理信息库MIB(Management Information Base)。MIB在被管理的实体中创建了命名对象，并规定了其类型。 总之，SMI建立规则，MIB对变量进行说明，而SNMP完成网管的动作。\n管理信息结构SMI SMI的功能应当有三个：被管对象应怎样命令；用来存储被管对象的数据类型有哪些；在网络上传送的管理数据应如何编码。\n被管对象的命名\nSMI规定，所有被管对象都必须处在对象命名树(object naming tree)上。 被管对象的数据类型\nSMI使用基本的抽象语法记法1（即ISO制定的ASN.1）来定义数据类型，但又增加了一些新的定义。SMI把数据类型分为两大类：简单类型和结构化类型。 编码方法\nSMI使用ASN.1制定的基本编码规则BER(Basic Encoding Rule)进行数据的编码。BER指明了每种数据的类型和值。ASN.1把所有的数据元素都表示为T-L-V三个字段组成的序列。T字段(Tag)定义的数据的类型，L字段(Length)定义V字段的长度，而V字段(Value)定义数据的值。 管理信息库MIB 所谓“管理信息”就是指在互联网的网管框架中被管对象的集合。被管对象必须维持可供管理程序读写的若干控制和状态信息。这些被管对象构成了一个虚构的信息存储器，所以才称为管理信息库MIB。管理程序就使用MIB中这些信息的值对网络进行管理（如读取或重新设置管理这些值）。只有在MIB中的对象才是SNMP所能够管理的。\nSNMP的协议数据单位和报文 实际上，SNMP的操作只有两种基本的管理功能，即：\n“读”操作，用Get报文来检测各被管对象的状况； “写”操作，用Set报文来改变各被管对象的状况。 SNMP的这些功能通过探询操作来实现，即SNMP管理进程定时向被管理设备周期性地发送探询信息。探寻的好处是：第一，可使系统相对简单；第二，能限制通过网络所产生的管理信息的通信量。\n当SNMP不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为陷阱(trap)，表示他能够捕捉“事件”。但这种陷阱信息的参数是受限制的。\n当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达到某些门限值的事件（这就叫做过滤）。这种方法的好处是：第一，仅在严重事件发生时才发送陷阱；第二，陷阱信息很简单且所需要的字节数很少。\n总之，使用探询（至少是周期性地）以维持对网络资源的实时监视，同时也采用陷阱机制报告特殊事件，使用SNMP成为一种有效的网络管理协议。\nSNMP使用无连接的UDP，因此在网络上传送SNMP报文的开销较小。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-18-snmp/","summary":"\u003cp\u003e计算机网络/应用层/简单网络管理协议SNMP\u003c/p\u003e","title":"简单网络管理协议SNMP"},{"content":"计算机网络/应用层/动态主机配置协议DHCP\n在协议软件中的参数赋值的动作叫做协议配置。具体的配置信息有哪些取决于协议栈。例如，连接到互联网的计算机的协议软件配置的项目包括：\nIP地址； 子网掩码； 默认路由器的IP地址； 域名服务器的IP地址。 用人工进行协议配置很不方便，而且容易出错。因此，应当采用自动协议配置的方法。互联网现在广泛使用的而是动态主机配置协议DHCP(Dynamic Host Configuration)，它提供了一种机制，称为即插即用网(plug-and-play network)。这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。\nDHCP对运行客户软件和服务器软件的计算机都适用。DHCP适用客户服务器方式。\n需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文(DHCPDISCOVER)（将目的IP地址置为全1，即255.255.255.255），这时该主机称为DHCP客户。 在本地网络上的所有主机都能收到这个广播报文，但只有DHCP服务器才对此广播报文进行回答。 DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的IP地址池(address pool)中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文(DHCPOFFER)。 DHCP中继代理(relay agent)：\n为了避免DHCP服务器的数量太多。因此现在是每一个网络至少有一个DHCP中继代理（通常是一台路由器），它配置了DHCP服务器的IP地址信息。当DHCP中继代理收到主机A以广播形式发送的发现报文后，以单播方式向DHCP服务器转发此报文，并等待其回答。收到DHCP服务器回答的提供报文后，DHCP中继代理再把此提供报文发回给主机A。DHCP报文只是UDP用户数据报的数据。\nDHCP服务器分配给DHCP客户的IP地址是临时的，因此DHCP客户只能在一段有限的时间内使用这个分配到的IP地址。DHCP协议称这段时间为租用期(lease period)。DHCP客户使用的UDP端口是68，而DHCP服务器使用的UDP端口是67。DHCP很适合于经常移动位置的计算机。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-16-dhcp/","summary":"\u003cp\u003e计算机网络/应用层/动态主机配置协议DHCP\u003c/p\u003e","title":"动态主机配置协议DHCP"},{"content":"计算机网络/应用层/电子邮件\n电子邮件概述 一个电子邮件系统应具有三个主要组成构件，这就是用户代理、邮件服务器、以及邮件发送协议和邮件读取协议。\n电子邮件由信封(envelope)和内容(content)两部分组成。在邮件的信封上，最重要的就是收件人的地址。电子邮件地址如下：\n用户名@邮件服务器的域名\n简单邮件传送协议SMTP（邮件发送协议） SMTP规定了在两个互相通信的SMTP进程之间应如何交换信息。\nSMTP规定了14条命令和21种应答信息。每条命令用几个字母组成，而每一种应答信息一般只有一行信息，由一个3位数字的代码开始，后面附上（也可不附上）很简单的文字说明。\n连接建立\n发件人的邮件送到发送方邮件服务器缓存后，SMTP客户就每隔一定时间对邮件缓存扫描一次。如发现有邮件，就使用SMTP的熟知端口号码25与接收方服务器的SMTP服务器建立TCP连接。在连接建立后，接收方SMTP服务器要发出“220 Service ready”（服务就绪）。然后SMTP客户向SMTP服务器发出HELO命令，附上发送方的主机名。SMTP服务器若有能力接收邮件，则回答：“250 OK”，表示已准备好接收。若SMTP服务器不可用，则回答“421 Service not available”（服务不可用）。SMTP不使用中间的邮件服务器。 邮件传送\n邮件的传送从MAIL命令开始。MAIL命令后面有发件人的地址。如：MAIL FROM wcyyf@outlook.com。若SMTP服务器已准备好接收邮件，则回答：“250 OK”。否则，返回一个代码，指出原因。如：451（处理时出错），452（存储空间不够），500（命令无法识别）等。\n下面跟着一个或多个RCPT命令，取决于把一个邮件发送给一个或多个收件人，其格式为RCPT TO: \u0026lt;收件人地址\u0026gt;。每发送一个RCPT命令，都应当有相应的信息从SMTP服务器返回，如：“250 OK”，表示指明的邮箱在接收方的系统中，或“550 No Such user here”（无此用户），即不存在此邮箱。\n再下面就是DATA命令，表示要开始传送邮件的内容了。SMTP服务器返回的信息是：“354 Start mail input; end with \u0026lt;CRLF\u0026gt;.\u0026lt;CRLF\u0026gt;”。若不能接收邮件则返回421（服务器不可用），500（命令无法识别）等。若邮件收到了，则返回“250 OK”，或返回差错代码。 连接释放\n邮件发送完毕后，SMTP客户应发送QUIT命令。SMTP服务器返回的信息是“221（服务器关闭）”，表示SMTP同意释放TCP连接。邮件传送的全部过程即结束。 SMTP的缺点：\n发送电子邮件不需要进过鉴别。方便了垃圾邮件作者。 SMTP传送非ASCII码的长文时，传输效率不高。 SMTP传送的邮件是明文，不利于保密。 ESMTP(Extended SMTP)新增的内容:\n客户端的鉴别 服务器接受二进制报文 服务器接受分块传送的大报文 发送前先检查报文的大小 使用安全传输TLS 使用国际化地址等 电子邮件的信息格式 一个电子邮件分为信封和内容两大部分。用户写邮件内容的首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上。所以用户不需要填写电子邮件信封上的信息。\n邮件内容首部包括一些关键字，后面加上冒号。最重要的关键字是：To和Subject。\n“To:”后面填入一个或多个收件人的电子邮件地址。\n“Subject:”是邮件的主题，它反映了邮件的主要内容。\n“Cc:”是抄送，意思是留下一个复写副本。\n“From:”和“Date:”表示发件人的电子邮箱地址和发信日期。这两项一般都是由邮件系统自动填入。\n“Reply-To:”即对方回信所要用的地址。\n邮件读取协议POP3和IMAP（邮件读取协议） 邮局协议POP是一个非常简单、功能有限的邮件读取协议\nPOP3服务器只有在用户输入鉴别信息（用户名和口令）后，才允许对邮箱进行读取。 只要用户从POP3服务器读取了邮件，POP3服务器就把该邮件删除。 另一个读取邮件的协议是网际报文存取协议IMAP。\n用户在自己的计算机上就可以操纵邮件服务器的邮箱，就像在本地操纵一样，因此IMAP是一个联机协议。 在用户未发出删除邮件的命令之前，IMAP服务器邮箱中的邮件一直保存着。 操作位置 操作内容 IMAP POP3 收件箱 阅读、标记、移动、删除邮件等 客户端与邮箱更新同步 仅在客户端内 发件箱 保存到已发送 客户端与邮箱更新同步 仅在客户端内 创建文件夹 新建自定义的文件夹 客户端与邮箱更新同步 仅在客户端内 草稿 保存草稿 客户端与邮箱更新同步 仅在客户端内 垃圾文件夹 接收并移入垃圾文件夹的邮件 支持 不支持 广告邮件 接收并移入广告文件夹的邮件 支持 不支持 基于万维网的电子邮件 使用万维网电子邮件不需要在计算机中再安装用户代理软件。浏览器本身可以向用户提供非常友好的电子邮件界面。 在浏览器和互联网上的邮件服务器之间传送邮件时，使用HTTP协议。但是在各邮件服务器之间传送邮件时，则仍然使用SMTP协议。 通用互联网邮件扩充MIME MIME概述 SMTP的缺点：\nSMTP不能传送可执行文件或其他的二进制对象。 SMTP限于传送7位的ASCII码。 SMTP服务器会拒绝超过一定长度的邮件。 SMTP的实现并没有按照SMTP的互联网标准。 在这种情况下就提出了通用互联网邮件扩充MIME。MIME并没有改动或取代SMTP。MIME的意图是继续使用原来的邮件格式，但增加了邮件主体结构，并定义了传送非ASCII码的编码规则。\nMIME主要包括以下三部分内容：\n5个新的邮件首部字段，它们可包含在原来的邮件首部中。 定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。 定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。 内容传送编码 7为ASCII编码。MIME对这种由ASCII码构成的邮件主体不进行任何转换。 qutoed-printable。这种编码方式适用于所传送的数据中只有少量的非ASCII码，用“=”加两个十六进制数字来表示非ASCII码数据。 对于任意的二进制文件，可用base64编码。这种编码方法先把二进制代码划分为一个个24位长的单位，然后把每一个24位单位划分为4个6位组。每一个6位组先转换为base64码，再用ASCII编码发送。 内容类型 MIME标准规定Content-Type说明必须含有两个标识符，即内容类型(type)和子类型(subtype)，中间用“/”分开。\n内容类型 子类型举例 说明 text（文本） plain,html,xml,css 不同格式的文本 image（图像） gif,jpeg,tiff 不同格式的静止图像 audio（音频） basic,mpeg,mp4 可听见的声音 video（视频） mpeg,mp4,quicktime 不同格式的影片 model（模型） vrml 3D模型 application（应用） octet-stream,pdf,javascript,zip 不同应用程序产生的数据 message（报文） http,rfc822 封装的报文 multipart（多部分） mixed,alternative,parallel,,digest 多种类型的组合 MIME的内容类型的multipart很有用，因为它使邮件增加了相当大的灵活性。\nmixed子类型允许单个报文含有多个相互独立的子报文，每个子报文可有自己的类型和编码。 alternative子类型报文含有同一数据的多种表示。 parallel子类型允许单个报文含有可同时显示的各个子部分（如图像和声音子部分必须一起播放）。 digest子类型允许单个报文含有一组其他报文（如从讨论中收集电子邮件报文）。 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-16-email/","summary":"\u003cp\u003e计算机网络/应用层/电子邮件\u003c/p\u003e","title":"电子邮件"},{"content":"计算机网络/应用层/万维网WWW\n万维网概述 万维网是一个大规模的、联机式的信息储藏所(Web)。万维网是一个分布式的超媒体(hypermedia)系统，它是超文本(hypertext)系统的扩充。\n超文本：\n包含指向其他文档的链接的文本(text)。超文本是万维网的基础。\n超媒体：\n与超文本的区别是文档内容不同，还包含其他方式的信息，如图形、图像、声音、动画和视频等。\n万维网以客户服务器方式工作。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户索要的万维网文档（页面page）。\n必须解决的问题 解决方法 如何标志文档 统一资源定位符URL 如何实现链接 超文本传送协议HTTP 如何显示不同风格的文档 超文本标记语言HTML 如何使用户方便的找到所需信息 搜索引擎 统一资源定位符URL 统一资源定位符URL(Uniform Resource Locator)是用来表示从互联网上得到的资源位置和访问这些资源的方法。URL实际上就是在互联网上的资源的地址。URL相当于一个文件名在网络范围的拓展。\n\u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt;\n\u0026lt;协议\u0026gt;是指出使用什么协议来获取文档。常用的协议有http，ftp等。\n\u0026lt;主机\u0026gt;是指该主机在互联网上的域名。\n\u0026lt;端口\u0026gt;http的默认端口是80，通常可忽略。\n\u0026lt;路径\u0026gt;文件存放路径，忽略时就指向主页(home page)。\nURL里面的字母部分大小写，但为了便于阅读，有时故意使用一些大写字母。\n超文本传送协议HTTP HTTP的工作过程 HTTP协议定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。\n每个万维网网点都有一个服务器进程，它不断地监听TCP的端口80，以便发现是否有浏览器（即万维网客户）向它发出连接建立请求。一旦监听到连接建立请求并建立TCP连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。最后，TCP连接就释放了。\n用户在点击鼠标链接某个万维网文档时，HTTP首先要和服务器建立TCP连接，这需要使用三报文握手。当建立TCP连接的三报文握手的前两部分完成后，万维网客户就把HTPP请求报文，作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。所以请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上两倍往返时间RTT。\nHTTP/1.1协议：\n使用持续连接。 持续连接有两种工作方式，即非流水线方式和流水线方式。 HTTP的报文结构 HTTP有两类报文：\n请求报文 响应报文 由于HTTP是面向文本的(text-oriented)，因此在报文中的每一个字段都是一些ASCII码串，因此各个字段的长度都是不确定的。\nHTTP报文都是由三个部分组成的。\n开始行，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行(Request-Line)，而在响应报文中的开始行叫做状态行(Status-Line)。 首部行，用来说明浏览器、服务器或报文主体的一些信息。 实体主体。 HTTP请求报文 请求报文的第一行“请求行”只有三个内容，即方法，请求资源的URL，以及HTTP的版本。\n方法（操作） 意义 OPTION 请求一些选项的信息 GET 请求读取有URL所标志的信息 HEAD 请求读取有URL所标志的信息的首部 POST 给服务器添加信息 PUT 在指明的URL下存储一个文档 DELETE 删除指明的URL所标志的资源 TRACE 用来进行环回测试的请求报文 CONNECT 用于代理服务器 下面是一个完整的HTTP请求报文的例子：\nGET /dir/index.htm HTTP/1.1{请求行使用了相对URL}\nHost: www.xyz.edu.cn{此行是首部行的开始，给出了主机的域名}\nConnect: close{告诉服务器发送完请求的文档后就可释放连接}\nUser-Agent: Mozilla/5.0{表明用户代理是使用Firefox浏览器}\nAccept-Language: cn{表示用户希望优先得到中文版本的文档}\n{请求报文的最后还有一个空行}\nHTTP响应报文 状态行包括三项内容，即HTTP的版本，状态码，以及解释状态码的简单短语。\n状态码 意义 1xx 表示通知信息，如请求收到了或正在处理 2xx 表示成功，如接受或知道了 3xx 表示重定向，如要完成请求还必须采取进一步的行动 4xx 表示客户的差错，如请求中有错误的语法或不能完成 5xx 表示服务器的差错，如服务器失效无法完成请求 HTTP响应的例子：\nHTTP/1.1 301 Moved Permanently{永久地转移了}\nLocation: http://www.xyz.edu/ee/index.html{新的URL}\nCookie 万维网站点可以使用Cookie来跟踪用户。Cooke可以在HTTP服务器和客户之间传递状态信息。\nCookie是这样工作的。当用户A浏览某个使用Cookie的网站时，该网站的服务器就为A产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目。响应报文中首部行是这样的：\nSet-cookie: 31d4d96e407aad42\n当A收到这个响应时，其浏览器就在它管理的特定Cookie文件中添加一行，其中包括服务器的主机名和cookie识别码。当A继续浏览这个网站时，每发送一个HTTP请求报文，其浏览器就会从其Cookie文件中取出这个网站的识别码，并放到HTTP请求报文的Cookie首部行中：\nCookie: 31d4d96e407aad42\n万维网的文档 超文本标记语言HTML 超文本标记语言HTML(HyperText Markup Language)就是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍。\nHTML定义了许多用于排版的命令。 HTML允许在万维网页面中插入图像。 HTML还规定了链接的设置方法。 XML(Extensible Markup Language)是可扩展标记语言，它和HTML很相似。但XML的设计宗旨是传输数据，而不是显示数据。XML不是要替换HTML，而是对HTML的补充。\nXHTML(Extensible HTML)是可扩展超文本标记语言，是作为一种XML应用被重新定义的HTML，并将逐渐取代HTML。所有新的浏览器都支持XHTML。\nCSS(Cascading Style Sheets)是层叠样式表，是一种样式表语言，用于为HTML文档定义布局。\n动态万维网文档 动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。由于浏览器每次请求的响应都是临时生成的，因此用户通过动态文档所看到的内容是不断变化的。动态文档的主要优点是具有报告当前最新信息的能力。\n这里增加了一个机制，叫做通用网关接口CGI(Common Gateway Interface)。CGI是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用。\n活动万维网文档 有两种技术可用于浏览器屏幕显示的连续更新。一种技术称为服务器推送(server push)，这种技术是将所有的工作都交给服务器。服务器不断地运行与动态文档相关联的应用程序，定期更新信息，并发送更新过的文档。\n另一种提供屏幕连续更新的技术是活动文档(active document)。这种技术是把所有的工作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段活动文档程序副本，使该程序副本在浏览器段运行。活动文档本身并不包括其运行所需的全部软件，大部分的支持软件是事先放在浏览器中的。\n由美国SUN公司开发的java语言就是一项用于创建和运行活动文档的技术。\n万维网的信息检索系统 全文检索搜索引擎：通过搜索软件(Spider)在互联网上各网站收集信息，可以从一个网站链接到另一个网站，像蜘蛛爬行。以此建立在线索引数据供用户查询。如Google，Baidu\u0026hellip; 分类目录搜索引擎：利用各网站向搜索引擎提交的关键词和网站描述等信息及虚拟性搜索。如Yahoo，sina\u0026hellip; 垂直搜索引擎：垂直搜索也是提供关键词来进行搜索的，但被放在一个行业知识的上下文中。 元搜索引擎：把用户提交的检索请求发送给多个独立的搜索引擎上去搜索，并把结果其中统一处理，以统一的格式提供给用户，因此是搜索引擎之上的搜索引擎。 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-15-www/","summary":"\u003cp\u003e计算机网络/应用层/万维网WWW\u003c/p\u003e","title":"万维网WWW"},{"content":"计算机网络/应用层/文件传送协议FTP\n文件共享协议：\n复制整个文件的：FTP，TFTP 联机访问：NFS FTP FTP使用客户服务器方式。一个FTP服务器进程可同时为多个客户提供服务。FTP的服务进程有两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。\n图中椭圆表示在系统中运行的进程。图中服务器端有两个从属进程：控制进程和数据传送进程。\n在进行文件传输时，FTP的客户和服务器之间要建立两个并行的TCP连接：“控制连接”和“数据连接”。FTP客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际传输文件的是“数据连接”。服务器端的控制进程在接收到FTP客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。\nNFS FTP并非对所有的数据传输都是最佳的。例如，要在远地计算机的一个很大的文件末尾添加一行信息。若使用FTP则要先把文件传送过来，添加信息后在传送过去。网络文件系统NFS则采用另一种思路。NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上好事读写数据。对于上述例子，NFS客户把要添加的数据和在文件后面写数据的请求一起发送到远地计算机，NFS服务器更新文件后返回应答信息。\nTFTP 简单文件传送协议TFTP也使用客户服务器方式，但它使用UDP数据报。因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。TFTP的工作很像停止等待协议。\n优点：\n可用于UDP环境 TFTP代码所占的内存小。这对较小的计算机或某些特殊用途的设备很重要。 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-14-ftp/","summary":"\u003cp\u003e计算机网络/应用层/文件传送协议FTP\u003c/p\u003e","title":"文件传送协议FTP"},{"content":"计算机网络/应用层/域名系统DNS\n应用层概述 应用层协议为不同的网络应用的应用进程之间的通信提供规则。每个应用层协议都是为了解决某一类的应用问题，而问题的解决又要通过位于不同主机的多个应用进程之间的通信和协同工作来完成。应用层的具体内容就是精确定义这些通信规则。\n域名系统概述 域名系统DNS(Domain Name System)是互联网使用的命名系统，用来把便于人们使用的机器名称转换为IP地址。\n互联网的域名系统DNS被设计成为一个联机分布式数据库系统，并采用客户服务器方式。\n当某一个应用进程需要把主机名解析为IP地址时，该应用进程就调用解析程序(resolver)，并称为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报的方式发给本地域名服务器。本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用进程获得目的主机的IP地址后即可进行通信。\n若本地域名服务器不能回答该请求，则此域名服务器就暂时称为DNS的另一个客户，并向其他域名服务器发出查询请求。这种过程直至找到能够回答该请求的域名服务器为止。\n互联网的域名结构 互联网采用层次树状结构的命名方法。\n每一个域名都由标号(label)序列组成，而各标号之间用点隔开。DNS规定，域名中的标号都由英文字母和数字组成，每一个标号不超过63个字符（但为了记忆方便，最好不要超过12个字符），不区分大小写。标号中除连字符(-)外不能使用其他的标点符号。级别最低的域名写在最左边，级别最高的域名写在最右边。由多个标号组成的完整域名总共不超过255个字符。\n顶级域名：\n国家顶级域名nTLD：如cn（中国），us（美国）等等。 通用顶级域名gTLD：如com（公司企业），org（非营利组织），net（网络服务机构）等等。 基础服务结构域名：只有一个，即arpa，用于反向域名解析。 二级域名，我国把二级域名划分为两类：\n类别域名：如ac（科研机构），com（企业），edu（教育机构）等等。 行政区域名：如bj（北京市），js（江苏省）等等。 域名服务器 上面讲述的域名体系是抽象的。但具体实现域名系统则是使用分布在各地的域名服务器。理论上，可以让每一级的域名都有一个相对应的域名服务器，但这样会使服务器数量太多，运行效率降低。因此DNS就采用划分区的办法来解决这个问题。\n一个服务器所负责管辖的（或有权限的）范围叫做区(zone)。每一个区设置响应的权限域名服务器，用来保存该区中所有主机的域名到IP地址的映射。区是“域”的子集。\n根域名服务器(root name server)：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根服务器都知道所有的顶级域名服务器的域名和IP地址。不管是哪一个本地域名服务器，只要自己无法解析，就首先求助于根域名服务器。全球共有13组根服务器，分布在588个地点(IPv4)。代号A~M。采用任播技术。在许多情况下，根域名服务器并不直接把待查询的域名直接转换成IP地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。 顶级域名服务器（TLD服务器）：负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时，可能给出最后的结果，也可能是下一步应当找的域名服务器的IP地址。 权限域名服务器：负责一个区的域名服务器。当一个权限域名服务器不能给出最后的查询回答时，就告诉DNS客户，下一步应当找哪一个权限域名服务器。 本地域名服务器(local name server)：当一台主机发出DNS查询请求时，这个查询请求就发送给本地域名服务器。非常的重要。 域名解析过程：\n本机向本地域名服务器的查询一般都是采用递归查询。即“你帮我查”。 本地服务器向根服务器的查询一般是采用迭代查询。即“你告诉我怎么查”。 为了提高DNS的查询效率，在域名服务器中广泛使用了高速缓存。高速缓存用来存放最近查询过的域名已经从何处获得域名映射信息的记录。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-13-dns/","summary":"\u003cp\u003e计算机网络/应用层/域名系统DNS\u003c/p\u003e","title":"域名系统DNS"},{"content":"计算机网络/运输层/TCP的运输连接管理\nTCP是面向连接的协议。运输连接有三个阶段：连接建立、数据传送和连接释放。\nTCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，被动等待连接建立的应用进程叫做服务器(server)。\nTCP的连接建立 具体过程： 客户进程A创建首先传输控制模块TCB，然后在打算建立TCP连接时，向服务器B发出连接请求报文段（首部中同步位SYN=1，初始序号seq=x）。这时，TCP客户进程进入SYN-SENT（同步已发送）状态。 B收到连接请求报文段后，如果同意建立连接，则向A发送确认报文段（同部位SYN=1，确认位ACK=1，确认号ack=x+1，初始序号seq=y）。这时，TCP服务器进入SYN-RCVD（同步收到）状态。 A收到B的确认后，还要向B发送确认报文段（确认位ACK=1，确认号ack=y+1，序号seq=x+1）。A进入ESTABLISHED（已建立连接）状态。 B收到A的确认后，也进入ESTABLISHED状态。 总结：请求连接则置同步位SYN=1，确认连接就置确认位ACK=1（TCP规定，SYN报文段不能携带数据，但要消耗一个序号；ACK报文段可以携带数据，但如果不携带数据则不消耗序号）。\n个人思考： 可以将三次握手看做四次，即建立连接的双方都要有发送请求和接收确认两个步骤才能最终建立连接。这样可以有效避免确认报文迟到造成的单方面的误认为连接，同时使连接程序适应性更强，每个TCP进程在连接建立过程中是平等的。\nTCP的连接释放 具体过程 A的应用进程先向B发送连接释放报文段（终止控制位FIN=1，序号seq=u），并停止发送数据，进入FIN-WAIT-1（终止等待1）状态。 B收到连接释放报文段后即发出确认报文段（确认位ACK=1，序号seq=v，确认号ack=u+1），然后B进入CLOSE-WAIT（关闭等待）状态。此时A到B方向的连接已经释放，B若要发送数据，A仍要接收。 A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。 B若没有要向A发送的数据了，就发送连接释放报文段（终止位FIN=1，序号seq=w，确认号ack=u+1），然后B就进入LAST-ACK（最后确认）状态，等待A的确认。 A收到B的连接释放报文段后，必须对此发出确认（ACK=1，ack=w+1，seq=u+1）。然后进入TIME-WAIT（时间等待）状态。此时，TCP连接还没有释放掉。必须经过2倍最长报文段寿命(MSL)时间后（通常MSL=2分钟），TCP连接结束。 总结：请求释放连接则置FIN=1，确认释放则置ACK=1。\n为什么要等待2MSL时间？\n为了保证A发送的最后一个ACK报文段能够到达B。 防止“已失效的连接请求报文段”出现在本连接中。 保活计时器：\n客户端主机出现故障时，服务器会白白等待下去。为此需要设置保活计时器。\n服务器每收到一次客户的数据，就重置计时器，时间通常是两小时。若两小时没有收到客户端的数据，服务器就发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出现了故障，接着的关闭这个连接。\nTCP的有限状态机 粗实线箭头表示对客户进程的正常变迁。粗虚线箭头表示对服务器进程的正常变迁。另一种细线箭头表示异常变迁。\n参考文献：《计算机网络（第7版）》谢希仁著\n","permalink":"https://yyf.zone/notes/2021-1-12-connectionmanagement/","summary":"\u003cp\u003e计算机网络/运输层/TCP的运输连接管理\u003c/p\u003e","title":"TCP的运输连接管理"},{"content":"计算机网络/运输层/TCP的拥塞控制\n拥塞控制概述 在某段时间，若网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。\n$\\sum对资源的需求 \u0026gt; 可用资源$\n网络拥塞往往是由很多因素引起的，简单的增加网络资源，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。\n拥塞控制与流量控制的关系密切，它们之间也存在着一些差别。所谓拥塞控制就是防止过多的数据注入网络中，这样可以避免网络中的路由器或链路过载。拥塞控制是一个全局性的过程。相反，流量控制往往是指点对点通信量的控制，是个端到端的问题。\n进行拥塞控制需要付出代价。需要获得网络内部流量分布的信息，还需要在结点之间交换信息和各种命令。这样就产生了额外的开销，所以在设计拥塞控制策略时，必须全面权衡得失。\n从控制理论的角度可以将拥塞控制分为开环控制和闭环控制两种方法。开环控制就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个网络运行起来，就不再进行改进了。闭环控制就是基于反馈环路的概念，主要有以下几种措施：\n监测网络系统以便检测到拥塞在何时、何处发生。 把拥塞发生的信息传送到可采取行动的地方。 调整网络系统的运行以解决出现的问题。 监测网络拥塞的指标有：由于缺少缓存空间而被丢弃的分组的百分数、平均队列长度、超时重传的分组数、平均分组时延、分组时延的标准差等等。\nTCP的拥塞控制方法（运输层） TCP主要采用基于窗口的拥塞控制。发送方维持一个叫做拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络拥塞程度，并且动态地变化。发送方的窗口上限值取决于接收方窗口rwnd和拥塞窗口cwnd。\n发送方的窗口上限值 = $Min[rwnd,cwnd]$\n具体算法分四个部分：慢开始(slow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)和快恢复。为叙述方便起见，我们用报文段的个数作为窗口大小的单位，这样可以使用较小的数字来阐明原理。\n慢开始和拥塞避免 慢开始算法的思路是在不清楚网络状况时，让拥塞窗口数值从小到大逐渐增加。先设置cwnd=1，然后每经过一个传输轮次，拥塞窗口cwnd就加倍，即按指数规律增大。在TCP的实际运行中，发送方只要收到一个新报文段的确认，其拥塞窗口cwnd就立即加1。\n为了防止拥塞窗口cwnd增加过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量：\n当$cwnd\u0026lt;ssthresh$时，使用上述慢开始算法。 当$cwnd\u0026gt;ssthresh$时，停止使用慢开始算法，改用拥塞避免算法。 当$cwnd=ssthresh$时，两种算法都可以使用。 拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，即按线性规律缓慢增长。\n当网络发送超时，发送方判断为网络拥塞，于是调整慢开始门限$ssthresh=cwnd/2$，同时设置拥塞窗口cwnd=1，进入慢开始阶段。\n快重传和快恢复 在报文段丢失的情况下，如果发送方迟迟收不到确认，就会产生超时，就会误以为网络发生拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口又设置为1，因而降低了传输效率。\n采用快重传算法可以让发送方今早知道发生了个别报文段的丢失，避免不必要的超时发生。快重传算法规定，接收方收到了失序的报文段也要立即发出对已收到的报文段的重复确认，而不是等待发送数据时进行捎带确认。发送方只要接收到3个重复确认，就立即进行重传。这样就不会出现超时，发送方就不会误认为出现了网络拥塞。\n发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值$ssthresh=cwnd/2$，同时设置拥塞窗口$cwnd=ssthresh$。并开始执行拥塞避免算法。\n总结：\n发生超时，则慢开始，同时调整门限值； 超过门限，则避免拥塞； 报文丢失，则快重传和快恢复。 主动队列管理AQM（网络层） 路由器的队列通常按照“先进先出”FIFO(First In First Out)的规则处理到来的分组，当队列已满时，以后到达的所有分组将被丢弃。这就叫做尾部丢弃策略。\n全局同步：若发生尾部丢弃，就可能影响到很多条TCP连接，结果使许多TCP连接在同一时间突然都进入到慢开始状态。\n全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。为避免发生全局同步现象，提出了主动队列管理AQM(Active Queue Management)。所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。应当在队列长度到达某个值得警惕的数值时（即当网络拥塞有了征兆时），就主动丢弃到达的分组。\n随机早期检测RED算法：\n若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。 若平均队列长度超过最大门限，则把新到达的分组丢弃。 若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率p把新到达的分组丢弃（这就体现了丢弃分组的随机性）。 参考文献：《计算机网络（第7版）》谢希仁著\n","permalink":"https://yyf.zone/notes/2021-1-11-congestioncontrol/","summary":"\u003cp\u003e计算机网络/运输层/TCP的拥塞控制\u003c/p\u003e","title":"TCP的拥塞控制"},{"content":"计算机网络/运输层/TCP的流量控制\n利用滑动窗口实现流量控制（适当的慢一点） 所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。\n利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。\n发送方的发送窗口不能超过接收方给出的接收窗口的数值。 在零窗口报文发送后，若接收方发送的非零窗口的通知无法到达发送方就容易出现互相等待的死锁局面。 TCP为每一个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动计数器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段。而对方在确认这个探测报文时给出了现在的窗口值。若窗口仍然为零，则重置持续计时器。若窗口不是零，那么死锁打破。 TCP的传输效率（适当的快一点） 如何控制TCP发送报文段的时机？\n机制 只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。 由应用程序指明要求发送报文段，即推送(push)操作。 发送方的计时器期限到了，就把已有的缓存数据装入报文段（长度不能超过MSS）发送出去。 存在的问题及解决方法 问题一：发送的数据少时，效率过低（发送的数据少） 适当推迟发回确定报文，并尽量使用捎带确认的方法。\nNagle算法：\n若应用程序把数据逐个字节地送到TCP缓存。TCP就把第一个字节先发送出去，把后面的数据字节缓存起来。当第一个字节的确认收到后，把后面到达的数据组装成报文段发送出去（即不使用流水线传输）。\n问题二：糊涂窗口综合征（可接收的数据少，接收方的TCP缓存释放缓慢） 让接收方等待一段时间，使得 1)接收缓存已有足够空间容纳一个最长的报文段；或者 2)接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确定报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据累积成足够大的报文段，或达到接收方缓存空间的一半。\n上述两种方法可配合使用。\n参考文献：《计算机网络（第7版）》谢希仁著\n","permalink":"https://yyf.zone/notes/2021-1-10-flowcontrol/","summary":"\u003cp\u003e计算机网络/运输层/TCP的流量控制\u003c/p\u003e","title":"TCP的流量控制"},{"content":"计算机网络/运输层/TCP可靠传输的实现\n可靠传输的工作原理 在理想的传输条件下，不需要采取任何措施就能够实现可靠传输。\n理想的传输条件有一下两个特点：\n传输信道不产生差错。 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。 然而这是不可能的。我们可以使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理接收到的数据时，及时告诉发送方适当降低发送数据的速度。下面介绍一些简单的可靠传输协议。\n停止等待协议 “停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。\n1. 无差错情况：略 2. 出现差错: 设A为发送方，B为接收方。B接收报文$M_{1}$时检测出差错，就丢弃$M_{1}$，其他什么也不做。A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送的分组。这就叫做超时重传。重传时间的设置很有讲究，下回详解。\n3. 确认丢失和确认迟到 B收到了分组$M_{1}$，并发送确认。但A没有接收到确认（由于网络原因丢失或迟到），于是A在重传时间到了之后重传分组。假定B又收到了重传的分组$M_{2}$，协议规定，B的应对行为如下：\n丢弃这个重复的分组$M_{2}$，不向上层交付。 再次向A发送确认。 A如果收到迟到的确认，则直接丢弃。\n使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。这类协议常称为自动重传请求ARQ(Automatic Repeat reQuest)停止等待协议优点是简单，但是缺点是信道利用率太低。\n为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输方式就是发送方可以连续发送多个分组，不必每发送一个分组就停顿下来等待对方的确认。\n当使用流水线传输方式时，就要使用下面介绍的连续ARQ协议和滑动窗口协议。\n连续ARQ协议 滑动窗口协议比较复杂，是TCP协议的精髓所在。这里给出连续ARQ协议最基本的概念。\n发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。\n接收方采用累积确认的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都已经正确收到。\nTCP可靠传输的实现 滑动窗口 TCP的滑动窗口是以字节为单位的。\n发送方A的发送窗口： 发送窗口表示：在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。 发送窗口里面的序号表示允许发送的序号。A的发送窗口一定不能超过B的接收窗口数值。 发送窗口后沿的后面部分表示已经发送且已经收到了确认。发送窗口的前沿前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间。 发送窗口的位置由前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的后沿不可能向后移动，因为不能撤销已收到的确定。发送窗口前沿通常是不断向前移动。 在接收方通知的窗口缩小时，发送方的前沿有可能向后收缩。但TCP标准强烈不赞成这样做。 接收方B的接收窗口：\nB只能对按序收到的数据中的最高序号给出确认。 窗口和缓存的关系： 发送缓存用来暂时存放：\n发送应用程序传送给发送方TCP准备发送的数据； TCP已发送出但尚未收到确认的数据。 发送窗口通常只是发送缓存的一部分。已确认的数据应当从发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。\n接收缓存用来暂时存放：\n按序到达的、但尚未被接收应用程序读取的数据； 未按序到达的数据。 如果收到的分组被检测出有差错，则要丢弃。如果接收的应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到零。\n超时重传时间的选择 TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。这种重传的概念很简单，但是重传时间的选择却是TCP最复杂的问题之一。\n如果重传时间设置得太短，就会引起不必要的重传，使网络负荷增大。但若把重传时间设置得太长，则又使网络的空闲时间增大，降低传输效率。\n报文段的往返时间RTT：报文段发出的时间和收到相应的确认的时间之差。\n加权平均往返时间$RTT_{s}$:\n第一次测量到RTT样本时，\n$RTT_{s}=RTT$\n此后每测量到一个新的RTT样本：\n$new RTT_{S}=(1-\\alpha)\\times oldRTT_{S}+\\alpha \\times new RTT$\n超时重传时间RTO(Retransmission Timee-Out)应略大于上面得出的加权平均时间$RTT_{S}$\n$RTO=RTT_{S}+4\\times RTT_{D}$\n$RTT_{D}$是RTT的偏差的加权平均值，它与$RTT_{s}$和新的RTT赝本之差有关。\n当第一次测量时\n$RTT_{D}=\\frac{1}{2}RTT$\n此后\n$newRTT_{D}=(1-\\beta)\\times oldRTT_{D}+\\beta \\times \\vert RTT_{s}-newRTT \\vert$\n如何判定此确定报文段是先发送的报文段的确定，还是对后来重传的报文段的确定？\nKarm算法：\n在计算加权平均RTTS时，只要报文段重传了，就不采用其往返时间样本。 报文段每重传一次，就把重传时间RTO增大一些。 选择确认SACK 若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据？答案是可以的。选择确认就是一种可行的处理方法。\n如果要使用选择确认SACK，那么在建立TCP连接时，就要在TCP首部的选项中加上“允许SACK”的选项，而双方必须都事先商定好。\n参考文献：《计算机网络（第7版）》谢希仁著\n","permalink":"https://yyf.zone/notes/2021-1-10-reliabletransmission/","summary":"\u003cp\u003e计算机网络/运输层/TCP可靠传输的实现\u003c/p\u003e","title":"TCP可靠传输的实现"},{"content":"计算机网络/运输层/TCP报文段的首部格式\nTCP报文段的首部格式 TCP报文段分为首部和数据部分。首部的前20个字节是固定的，后面根据需要可增加$4n$字节的选项。\n字段意义如下：\n源端口和目的端口 各占2个字节，分别写入源端口号和目的端口号。 序号 占4字节，指明本报文段所发送的数据的第一个字节的序号。TCP连接中传送的字节流中的每一个字节都按顺序编号。 确认号 占4字节，指明期望收到对方下一个报文段第一个数据字节的序号。 若确认号$=N$，则表明：到序号$N-1$为止的所有数据都已正确收到。\n数据偏移 占4位，指明数据起始处距离报文段起始处有多远。实际上是指出TCP报文段的首部长度。 保留 保留为今后使用，但目前应置为0。 控制位 （置1有效，置0无效） 紧急URG(URGent) 告诉系统此报文段有紧急数据，应尽快传送（相当于高优先级的数据）。与紧急指针字段匹配使用。 确认ACK(ACKnowledgment) TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。 推送PSH(PuSH) 指明本报文段希望尽快交付。用于交互式通信时，可直接创建报文并发送，不用等待缓存填满。 复位RST(ReSeT) 表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后重新建立运输连接。 同步SYN(YNchronization)emsp; 在连接建立时用来同步序号。对放若同意建立连接，则在报文段中使SYN=1和ACK=1。 终止FIN(FINis) 用来释放连接。 窗口 占2字节。窗口指的是发送本报文段一方的接收窗口。之所有有这个限制，是因为接收方的数据缓存空间是有限的。本字段的值可以作为接收方设置其发送窗口的依据。 窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着。\n检验和 占2字节。同UDP。 紧急指针 占2字节。紧急指针仅在URG=1时有意义，它指出了紧急数据末尾在报文段中的位置。 选项 长度可变，最长可达40字节。没有使用时，TCP的首部长度为20字节。 最大报文段长度MSS(Maximum Segment Size) MSS是每一个TCP报文段中的数据字段的最大长度。默认值为536字节长。 窗口扩大选项 占3个字节。其中有一个字节表示移位值S，新窗口值从16位扩大到$(16+S)$，用于获得高吞吐率的应用情形。 时间戳选项 占10个字节。其中最主要的字段是时间戳值字段（4字节）和时间戳回送回答字段（4字节）。此选项有两个功能：第一，用来计算往返时间RTT；第二，用来处理TCP序号超过$2^{32}$的情况。 参考文献：《计算机网络（第7版）》谢希仁著\n","permalink":"https://yyf.zone/notes/2021-1-9-headoftcp/","summary":"\u003cp\u003e计算机网络/运输层/TCP报文段的首部格式\u003c/p\u003e","title":"TCP报文段的首部格式"},{"content":"计算机网络/运输层/传输控制协议TCP概述\nTCP的主要特点： TCP是面向连接的运输层协议。应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。类似“打电话”。 每一条TCP连接只能有两个端点(endpoint)。 TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。 TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来存放双向通信的数据，TCP会在合适的时候将数据发送出去或者读取。 面向字节流。TCP把应用程序交下来的数据仅仅看成一连串的无结构的字节流。TCP不保证接收方应用程序所接收到的数据块和发送方应用程序所发送出的数据块具有对应大小的关系。接收方的应用程序必须有能力识别收到的字节流。 TCP的连接 TCP把连接作为最基本的抽象。TCP连接的端点是抽象的套接字，即（IP地址：端口号）。同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。\n套接字socket=（IP地址：端口号）\nTCP连接::={$socket_{1},socket_{2}$}={($IP_{1}:port_{1}$),($IP_{2}:port_{2}$)}\n参考文献：《计算机网络（第7版）》谢希仁著\n","permalink":"https://yyf.zone/notes/2021-1-8-overviewoftcp/","summary":"\u003cp\u003e计算机网络/运输层/传输控制协议TCP概述\u003c/p\u003e","title":"传输控制协议TCP概述"},{"content":"计算机网络/运输层/用户数据报协议UDP\n概述 UDP只在IP数据报服务之上增加了复用和分用功能和差错检测功能。\nUDP的主要特点：\nUDP是无连接的，即发送数据之前不需要建立连接，发送数据结束后不需要释放连接，这样可以减少开销和时延。 UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。 UDP是面向报文的。UDP在应用程序交下来的报文之前添加首部后就向IP层交付。 UDP没有拥塞控制。允许主机以恒定速率发送数据，允许在网络发生拥塞时丢失一些数据，但不允许数据有太大的时延，这对实时应用很重要。 UDP支持一对一、一对多、多对一、多对多的交互通信。 UDP的首部开销小，只有8个字节，比TCP首部的20个字节要短。 针对UDP可以引起拥塞和数据丢失，一些实时应用会对UDP增加一些提高可靠性的措施，比如采用前向纠错或重传已丢失的报文。\nUDP的首部格式 UDP的首部字段很简单，只有8个字节，由4个字段组成，每个字段都是2字节。各字段的意义如下：\n源端口 源端口号。在需要对方回信时选用，不需要时可用全0； 目的端口 目的端口号。必须有。 长度 UDP用户数据报的长度，最小值是8（仅有首部）。 检验和 检测UDP用户数据报在传输中是否有错。有错就丢弃。 UDP的功能实现 分用和复用功能： 基于端口可以实现。当运输层从IP层收到UDP数据报时，根据首部中的目的端口把UDP数据报通过相应的端口，上交给应用程序。\n如果接收方UDP发现收到的报文中目的端口号不正确，就丢弃报文。并由ICMP发送“端口不可达”差错报文给发送方。traceroute中就是利用含有非法端口的UDP数据报来达到测试目的。\n差错检测功能： 计算检测和时，会在UDP数据报前临时增加12个字节的伪首部。伪首部既不向下传送也不向上递送，而仅仅是为了计算检验和。伪首部的内容如上图。\nUDP计算检验和的方法和IP数据报的方法相似，但UDP的检验和是把首部和数据部分一起都检验。发送段检验和计算方法如下：\n将全0放入检验和字段； 将伪首部以及数据报看成是由许多16位的字串接起来； 若UDP数据报的数据部分不是偶数个字节，则填入一个全0的字节（此字节不发送）； 按二进制反码求这些16位字的和。 设置检验和字段，使无差错时求和结果为全1。 接收端检测方法类似。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-8-udp/","summary":"\u003cp\u003e计算机网络/运输层/用户数据报协议UDP\u003c/p\u003e","title":"用户数据报协议UDP"},{"content":"运输层/运输层概述\n运输层协议概述 运输层的主要任务 网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。\n如图，运输层的通信好像就是沿水平方向直接传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。数据的传送是沿着图中的虚线方向（经过多个层次）传送的。逻辑通信的意思是“好像是这样通信，但事实上并非真的这样通信”。\n运输层的功能 运输层还要对收到的报文进行差错检测。在网络层中，IP数据报首部中的检验和字段，只检验首部是否出现差错。 运输层向高层用户屏蔽了下面网络核心的细节。 复用和分用应用层所有的应用进程都可以通过运输层再传送到IP层（网络层），这就是复用。运输层从IP层收到发给各应用进程的数据后，必须分别交付指明的各应用进程，这就是分用。 运输层的两个主要协议 用户数据报协议UDP(User Datagram Protocol) 传输控制协议TCP(Transmission Control Protocol) 数据单元 UDP用户数据报 TCP报文段(segment) 传输方式 在传送数据之前不需要建立连接 提供面向连接的服务 可靠性 不可靠的 可靠的 应用场景：\n运输层中端口的概念 端口就是对进程标识符进行“统一度量衡”操作。\n要解决的问题：\n为了实现运输层复用和分用的功能功能，我们必须对应用层的每个应用进程赋予一个非常明确的标志。\n遇到的困难：\n我们知道，在单个计算机中的进程是用进程标识符（一个不大的整数）来标志的。但是在互联网环境下，计算机的操作系统不同，不同的操作系统又使用不同格式的进程标识符。 把特定机器上运行的特定进程指明为通信的最后终点是不可行的。因为进程的创建和撤销都是动态的。 解决问题的方法：\n运输层使用协议端口号(Protocol port number)，或简称端口(port)。虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适端口，剩下的工作就由TCP或UDP来完成。此处的端口指软件端口。TCP/IP的运输层用一个16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。\n硬件端口：不同硬件设备进行交互的接口。 软件端口：应用层的各种协议进程与运输实体进行层间交互的一种地址。\n运输层端口号的分类:\n服务器端使用的端口号\n熟知端口号(well-known port number)或系统端口号，数值为0~1023。这些端口号指派给了TCP/IP最重要的一些应用程序。如下图。 登记端口号。数值为1024~49151。使用这类端口号必须在IANA登记，以防止重复。 客户端使用的端口号\n数值为49152~65535。这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。\n​\n应用程序 FTP TELNET SMTP DNS TFTP HTTP SNMP SNMP(trap) HTTPS 熟知端口号 21 23 25 53 69 80 161 162 443 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-7-overviewoftransportlayer/","summary":"\u003cp\u003e运输层/运输层概述\u003c/p\u003e","title":"运输层协议概述"},{"content":"网络层/多协议标签交换MPLS\n多协议标签交换MPLS 概述 多协议标签协议交换MPLS(MultiProtocal Label Switching)是一种在开放的通信网上利用标签引导数据高速、高效传输的新技术。多协议的含义是指MPLS不但可以支持多种网络层层面上的协议，还可以兼容第二层的多种数据链路层技术。\n特点：\n支持面向连接的服务质量。 支持流量工程，平衡网络负载。 有效地支持虚拟专用网VPN。 工作原理 MPLS的一个重要特点就是在MPLS域的入口处，给每一个IP数据报打上固定长度“标记”，然后对打上标记的IP数据报用硬件进行转发，这就使得IP数据报转发的过程大大地加快了。\nMPLS域(MPLS domain)是指该域中有许多彼此相邻的路由器，并且所有的路由器都是支持MPLS技术的标签交换路由器LSR(Label Switching Router)。\n入口结点：打上标签 LSR：转发+更新标签 出口结点：去除标签 MPLS首部的位置和格式 位置：从层次的角度看，MPLS首部就处在第二层和第三层之间。其实就是在以太网的帧首部和IP数据报的首部之间插入一个4字节的MPLS首部。\n格式：MPLS首部包括4个字段：\n标签值。占20位。 试验。占3位，目前保留用于试验。 栈S。占1位，在有“标签栈”时使用。 生存时间TTL。占8位，用来防止MPLS分组在域中兜圈子。 MPLS在负载平衡中的应用 MPLS有个重要的概念就是转发等价类FEC(Forwarding Equivalence Class)。所谓“转发等价类”就是路由器按照同样方式对待的IP数据报的集合。FEC的划分不受限制。 例如：\n目的IP地址与某一个特定IP地址前缀匹配的IP数据报集合。 所有源地址与目的地址都相同的IP数据报集合。 具有某种服务质量需求的IP数据报集合。 入口结点将同样FEC的IP数据报都指派同样的标签。即FEC和标签是一一对应的关系。这样可以使网络的负载较为平衡，网络管理员采用自定义的FEC就可以更好地管理网络的资源。这种均衡网络负载的做法也称为流量工程IE(Traffic Engineering)或通信量工程。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-6-mpls/","summary":"\u003cp\u003e网络层/多协议标签交换MPLS\u003c/p\u003e","title":"多协议标签交换MPLS"},{"content":"网络层/IPv6\nIPv6 IPv6地址 在IPv6中，每个地址占128位，地址空间大于$3.4\\times10^{38}$。\n冒号十六进制记法： 它把每个16位的值用十六进制表示，各值之间用冒号分隔，允许把数字前面的0省略。例如：\n68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF\n零压缩： 一连串连续的零可以用一对冒号取代。在任一地址中只能使用一次零压缩。例如\nFF05:0:0:0:0:0:0:B3\n可压缩为\nFF05::B3\nIPv6的地址分类 地址类型 二进制前缀 未指明地址 00\u0026hellip;0(128位)，可记为::/128。 环回地址 00\u0026hellip;1(128位)，可记为::1/128 多播地址 11111111(8位)，可记为FF00::/8 本地链路单播地址 1111111010(10位)，可记为FE80::/10 全球单播地址 （除上述四种外，所有其他的二进制前缀） IPv6数据报 IPv6数据报由两大部分组成，即基本首部(base header)和有效载荷(payload)。\n基本首部 与IPv4相比，IPv6对首部中的字段进行了如下更改：\n取消了首部长度字段，因为它的首部长度是固定的(40字节)。 取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。 取消了总长度字段，改用有效载荷长度字段。 取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。 把TTL字段改称为跳数限制字段，作用是一样的。 取消了协议字段，改用下一个首部字段。 取消了检验和字段。 取消了选项字段，而用扩展首部来实现选项功能。 各字段的作用如下:\n版本(version)\t占4位。指明协议的版本，对IPv6该字段是6。 通信量类(traffic class)\t占8位。这是为了区分不同数据报的类别或优先级。 流标号(flow label)\t占20位。IPv6的一个新的机制是支持资源预分配，并且允许路由器把每一个数据报与一个给定的资源分配相联系。IPv6提出流(flow)的抽象概念，“流”就是互联网上从特定源点到特定终点(单播或多播)的一系列数据报，而在这个“流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别有用。关于流标号可参考RFC 6437。 有效载荷长度(payload length)\t占16位。它指明IPv6数据报除基本首部以外的字节数。最大值是64KB。 下一个首部(next header)\t占8位。它相当于IPv4的协议字段或可选字段 当数据报没有拓展首部时，下一个首部字段的作用和IPv4的协议字段一样。 列表项当出现拓展首部时，下一首部字段的值就标识后面第一个拓展首部的类型。 跳数限制(hop limit)\t占8位。用来防止数据报在网络中无限期地存在。 源地址\t占128位。是数据报的发送端的IP地址。 目的地址\t占128位。是接收端的IP地址。 拓展首部 IPv6把原来IPv4首部中选项的功能都放在拓展首部中，并把拓展首部留给路径两端的源点和终点的主机来处理，而数据报途中的经过的路由器都不处理这些首部（只有一个首部例外，即逐跳选项拓展首部），这样大大提高了路由器的处理效率。\n在RFC 2460中定义了以下六种拓展首部：\n(1) 逐跳选项\n(2) 路由选项\n(3) 分片\n(4) 鉴别\n(5) 封装安全有效载荷\n(6) 目的站选项\n每一个拓展首部长度可以不同，但第一个字段都是8位的“下一首部”字段。此字段的值指出了在该拓展首部后面的字段是什么。当使用多个拓展首部时，应按以上的先后顺序出现。高层首部总是放在最后面。\n从IPv4向IPv6过渡 双协议栈。使一部分主机（或路由器）装有双协议栈：一个IPv4和一个IPv6。这表明它同时具有两种IP地址：一个IPv6地址和一个IPv4地址。 隧道技术。这种方法的要点是在IPv6数据报要进入IPv4网络时，把IPv6数据报封装为IPv4数据报。 ICMPv6 ICMPv6合并了地址解析协议ARP和网际组管理协议IGMP。\nICMPv6是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站和管理多播通信。\nICMPv6报文：\n差错报文 信息报文 邻站发现报文（ND协议） 组成员关系报文（MLD协议） 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-2-ipv6/","summary":"\u003cp\u003e网络层/IPv6\u003c/p\u003e","title":"IPv6"},{"content":"网络层/IP多播\nIP多播 一个源点发送到多个终点，即一对多的通信。与单播相比，在一对多的通信中，多播可大大节约网络资源。\n基本概念 多播路由器(multicast router) 在互联网范围的多播要靠路由器来实现，这些路由起必须增加一些能够识别多播数据报的软件，能够运行多播协议的路由器称为多播路由器。多播路由器当然也可以转发普通的单播IP数据包\n多播主干网(Multicast Backbone On the InterNET) MBONE可把分组传播给地点分散但属于一个组的许多台主机。\n多播地址 多播组的标识符就是IP地址中的D类地址。D类地址的前四位是1110，每一个D类地址标志一个多播组。多播地址只能用于目的地址，而不能用于源地址。\n多播数据报 多播数据报和一般的IP数据报的区别就是它使用D类IP地址作为目的地址，并且首部中的协议字段值是2，表明使用网际组管理协议IGMP。此外，对多播数据报不产生ICMP差错报文。因此，若在PING命令后面键入多播地址，将永远不会收到响应。\n局域网上的硬件多播 D类IP地址与以太网多播地址的映射关系。互联网号码指派管理局IANA拥有的以太网地址块的高24位为00-00-5E，第一个字节的最低位为1时即为多播地址，即01-00-5E-00-00-00到01-00-5E-7F-FF-FF。\n由于多播IP地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。\n3. 网际组管理协议IGMP IP多播需要两种协议，网际组管理协议IGMP和多播路由选择协议。IGMP协议并非在互联网范围内对所有多播组成员进行管理的协议。IGMP不知道多播组包含的成员数，也不知道这些成员都分布在那些网络上，等等。IGMP协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。\n显然，仅有IGMP协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，这就需要多播路由选择协议。\nIGMP协议和ICMP协议相似，使用IP数据报传递其报文。属于网际协议IP的一个组成部分。 IGMP的工作分成两个阶段：\n第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个IGMP报文，声明自己要称为改组成员。 第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。 IGMP协议还采取了一些措施来避免多播控制信息给网络增加大量的开销：\n在主机和多播路由器之间的所有通信都是使用IP多播。 多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要每个组都发送一个。 当同一个网络上连接有多个多播路由器时，它们能迅速和有效地选择其中的一个来探询主机的成员关系。 在IGMP的询问报文中有一个数值N，它指明一个最长响应时间。当收到询问时，主机在0到N之间随机选择发送响应所需要经过的时延。因此，若一台主机同时参加了多个多播组，则主机对每一个多播组选择不同的随机数。对应最小时延的响应最先发送。 同一组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。 IGMP的报文格式可参阅有关文档RFC 3376。\n4. 多播路由选择协议 多播路由选择协议实际上就是要找出以源主机为根节点的多播转发树。\n多播转发树 在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据报，但在多播转发树上的路由器不会收到重复的多播数据报（即多播数据报不应在互联网中兜圈子）。\n已有多种实用的多播路由选择协议，它们在转发多播数据报时使用以下的三种方法;\n泛洪与剪除。这种方法适合较小的多播组，而所有的组成员接入的局域网也是相邻接的。一开始，路由器转发多播数据报使用泛洪的方法（这就是广播）。\n为避免兜圈子，采用反向路径广播RPB(Reverse Path Broadcasting)策略。RPB的要点是：每一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进行这种检查很容易，只要从本路由器寻找到源点的最短路径上（之所以叫做反向路径，因为在计算最短路径时是把源点当作终点）的第一个路由器是否就是刚才把数据送来的路由器。若是，就向所有其他方向转发刚才收到的多播数据报，否则就丢弃而不转发。\n如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播组的成员，就应把它和下游的树枝一起剪除。 隧道技术。隧道技术适用于多播组在地理上很分散的情况。在通过不支持多播的网络时，将多播数据报进行再次封装，即加上普通数据报首部，使之成为向单一目的站发送单播数据报。通过该网络后，剥去首部，使它恢复成原来的多播数据报，继续向多个目的站转发。 基于核心的发现技术。这种方法对于多播组的大小在较大范围内变化时都适合。这种方法是对每一个多播组G指定一个核心(core)路由器，给出它的IP单播地址。核心路由器按照前面讲过的方法创建出对应于多播组G的转发树。假设核心路由器为R2，如果R1发出一个多播数据报，其目的地址是G的组地址，R2就向多播组G的成员转发这个多播数据报。如果R1发出的数据报是一个请求加入多播组G的数据报，R2就把这个信息加到它的路由中，并用隧道技术向R1转发每一个数据报的一个副本。 目前还没有在整个互联网范围使用的多播路由选择协议。下面是一些建议使用的多播路由选择协议。\n距离向量多播路由选择协议DVMRP（Distance Vector Multicast Routing Protocol）参考有关文档RFC 1075。 基于核心的转发树CBT（Core Based Tree)参考有关文档RFC 2189,2201。 开放最短通路优先的多播拓展MOSPF（Multicast extensions to OSPF）参考有关文档RFC 1585。 协议无关多播-稀疏方式PIM-SM（Protocol Independent Multicast-Spare Mode）参考有关文档RFC 4601。 协议无关多播-密集方式PIM-DM（Protocol Independent Multicast-Dense Mode)参考有关文档RFC 3973 参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-2-ipmulticast/","summary":"\u003cp\u003e网络层/IP多播\u003c/p\u003e","title":"IP多播"},{"content":"","permalink":"https://yyf.zone/categories/","summary":"","title":""},{"content":"计算机网络/网络层/虚拟专用网络VPN和网络地址转换NAT\n虚拟专用网络VPN 专用地址 只能用于一个机构内部通信的地址。专用地址只能用做本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。\n专用地址块：\n10.0.0.0到10.255.255.255（或记为10.0.0.0/8，它又称为24位块） 172.16.0.0到172.31.255.255（或记为172.16.0.0/12，它又称为20位块） 192.168.0.0到192.168.255.255（或记为192.168.0.0/16，它又称为16位块）\n专用网络 采用专用IP地址的互连网络称为专用互联网或本地互联网，或更简单点，就叫专用网。\n虚拟专用网络 利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网VPN(Virtual Private Network)。利用加密技术和隧道技术实现虚拟专用网。\n网络地址转换NAT 应用情形:专用网内部的一些主机本来已经分配到了本地IP地址，但现在又想和互联网上的主机通信（并不需要加密）。最简单的方法是设法再申请一些全球IP地址，但是全球IPv4地址已经所剩不多了。目前最常用的方法是采用网络地址转换。\n原理：这种方法需要在专用网络连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。\n总结：NAT技术就是在专用网络的主机和互联网通信时，利用IP地址转换表，共用NAT路由器的全球IP地址。\n参考文献：《计算机网络（第7版）》谢希仁著。\n","permalink":"https://yyf.zone/notes/2021-1-5-vpnandnat/","summary":"\u003cp\u003e计算机网络/网络层/虚拟专用网络VPN和网络地址转换NAT\u003c/p\u003e","title":"虚拟专用网络VPN和网络地址转换NAT"}]